{
    "url": "dummy",
    "title": "A Prototype Implementation of an Orthographic Software Modeling Environment",
    "authors": [
        "Colin Atkinson",
        "Dietmar Stoll",
        "Christian Tunjic",
        "Jacques Robin"
    ],
    "institutes": [
        "University of Mannheim, Germany",
        "University of Mannheim, Germany",
        "University of Mannheim, Germany",
        "Universidade Federal de Pernambuco, Recife, Brasil"
    ],
    "keywords": [
        "Orthographic Software Modeling",
        "Viewbased Modeling"
    ],
    "abstract": "Orthographic Software Modeling (OSM) is a viewcentric software engineering approach that aims to leverage the or thographic projection metaphor used in the visualization of physical objects to visualize software systems. Although the general concept of OSM does not prescribe speci\ufb01c sets of views, a concrete OSM environment has to be speci\ufb01c about the particular views to be used in a particular project. At the University of Mannheim we are developing a prototype OSM environment, nAOMi, that supports the views de\ufb01ned by the KobrA 2.0 method, a version of KobrA adapted for OSM. In this paper we provide an overview of the KobrA 2.0 metamodel underpinning nAOMi and give a small example of its use to model a software system.",
    "content": "introduction orthographic software modeling is based on three fundamental hypotheses that it is feasible to inte grate the many di\ufb00erent kinds of artifacts used in contempo rary software engineering methods within a single coherent methodology in which they are treated as that it permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for pro\ufb01t or commercial advantage and that copies bear this notice and the full citation on the \ufb01rst to copy to to post on servers or to redistribute to requires prior speci\ufb01c permission a vao july france copyright acm is feasible to create an e\ufb03cient and scalable way of support ing these views by generating them from a single underlying model using modelbased transformations and that it is feasible to provide an in tuitive metaphor for navigating around these many views by adapting the orthographic projection technique under pinning the cad tools used in other engineering figure orthographic as shown in figure the main advantages of using the idea of orthographic projection to de\ufb01ne the views used to visualize and described a system are that they can be organized according to a simple and easytounderstand metaphor and collectively represent all the properties of a system with minimal overlap and in practice this translates into a set of each containing well de\ufb01ned choices so called dimension that can be used to select individuals as shown in figure the main advantage of making the artifacts used to describe a software system views of a sum is that the number of pairwise coherence relationships that have to be maintained is reduced and new views can be in troduced by simply de\ufb01ning their relationship to the the importance of this advantage grows quickly as the size of the system and the complexity of the deployed development methodology another important ad vantage is that the dominance of one particular kind of view over the development process at the expense of other kinds of views graphical is reduced so that any appropriate type of views can be used to enrich the underlying description of the depending on the needs and skills of the stakeholder this makes it possible to subsume all view types under the overarch sum sum view centric environment artifact tools centric environment figure consistency dependencies in versus ing development process and methodology focusing on small development or based on transformations between abstraction although the details of how the views are created from the sum and how the sum is updated from the views are not central to the a natural implementation is to use the visualization and transformation technologies o\ufb00ered by model driven software engineering to explore the validity of these hypotheses at the versity of mannheim we have been developing a prototype osm modeling environment based on an enhanced version of the kobra method for kobra this was chosen as a basis for the known as the orthographic modeling environment because its views were designed with the precise goals of being genuine jections of a subject containing carefully selected subsets of information about that minimalistic in the sense that they should overlap to the smallest extent possible and contain the minimum necessary models and selectable via a set of independent which re\ufb02ect di\ufb00erent fundamental concerns of development abstraction composition or in other kobra already provided one of the sets of views for visualizing software systems of any rary more details about the actual views and mensions de\ufb01ned in kobra are presented in the following more information on osm can be found in and naomi is implemented as an eclipse plugin using the eclipse modeling framework as the underlying eling platform and uml tools to generate and edit the kobra metamodel on which the current version of naomi is based is a specialization of the uml metamodel composed of three separate packages one for the one for the views and one for the transformations the uml was chosen as the base language cause of its maturity and widespread making the environment usable to the largest possible body of uml elements not needed in kobra are excluded using ocl constraints while new elements or properties are transformation sum views figure kobra top level introduced by specializing existing the unique contribution of this paper is to elaborate on the structure of the kobra metamodel and how it is used to drive the three following sections each focus on one of the three main components of the metamodel the the views and the transformations this is followed by a brief overview of the osm navigation paradigm in tion before a small example of the approach is presented in section section then concludes the paper with related and future sum package figure depicts the internal structure of the sum age which is based on the uml there are three main two containing the structural and ioral constructs and one containing the straints that ensure that the metaclasses are used according to the kobra conventions and the classes subpackage of the structure package contains some of the most fundamental elements of the kobra such as class and the internal structure of this package is illustrated in figure ponentclass represents objects with complex and reusable while class captures simple objects that have only very simple or the modeler has to decide whether it is necessary to model a speci\ufb01c part of the system as a componentclass and include state charts and activity or whether it is su\ufb03cient to use a class is limited to using ocl componentclass inherits via from munications so it also has the isactive this makes figure kobra sum it possible to model whether its instances are active or active which can be used to model threads and processes start to execute their behavior as soon as they are created and perform operations a componentclass may exhibit complex in this behavior may be speci\ufb01ed in the form of uml state diagrams acceptable operation invocation and in the form of activities algorithms of uml interaction elements sequence can be derived from the activity elements and thus are not included in the as kobra aims to facilitate automatic checking of allowed sequences of operation protocol state machines are supported instead of general state since the latter include a large variety of elements not needed for specifying acceptable operation quences or automatic ocl constraints are used to prohibit the use of unwanted context componentclass only allow activity elements or protocolstatemachines ownedbehavior or ocliskindof protocolstatemachine for since kobra has no concept of roles for the use of role also needs to be the part association refers to owned properties of components whose attribute iscomposite is as kobra uses associations like nests and creates for required and provided are not connectors delegation and are not used in kobra either so ownedconnector is class generalizationset associationclass componentclass property usage association operation packageable element parameter acquires creates nests figure kobra classes context componentclass role ownedconnector collaborationuse representation views package the structure of the views package is illustrated in figure since most of the views de\ufb01ned in kobra are based on uml the view metamodels have similar elements to the sum the big di\ufb00erence to the sum is that there are no restrictions on the use of the view metamodel for views for a particular purpose such as supporting model checkers can be supported by adding elements unrelated to the the substructure of the views package re\ufb02ects the types and organization of the kobra views according to the view supported in naomi example in section at the top the views package is thus decomposed into the speci\ufb01cation and realization options of the sulation in turn are both decomposed into the behavioral and operational options of the projection with the exception of the behavioral these are also all subdivided into the service and type options of the granularity this with its two is an addition to the original version of the service view shows the publicly visible tionships of the subject componentclass to other while the type view shows the publicly ble relationships of the subject to simple as with the constraints have been de\ufb01ned to control what can go into each view and when they are well for ery a constraint enumerates all allowed elements shown in this in the some of the other constraints for the service view are since this view is a the internals of componentclasses are not context componentclass no nested classifiers no protocol nestedclassifier classes are only allowed if they are generalizations of any of its since a nentclass may inherit from a class as shown in the straints with context the following invariants ensure that only publicly visible attributes and operations are in this for both classes and componentclasses inherit from class service type instance service type structural specification operational service type protocol behavioral componentclassdependencies operationdependencies instance service type class service type structural realization operational service type behavioral algorithm views concretesyntax subject figure kobra views package context class only allow classes that are direct or indirect generalizations of componentclasses in this view ccgeneralization generalization ocliskindof componentclass generalization oclistypeof ccgeneralization or ccgeneralization only public attributes in this view ownedattribute only public operations are allowed in the specification ownedoperation only operation signatures are shown in this so and as well as activities are which is re\ufb02ected in the last context operation only the signature of the operation is shown not its behavior name refers to the activities of the or dependencies method precondition postcondition transformations package the package allviews provides the foundation for fying the transformations between the sum and the views in both part of the contents are shown in figure the abstraction concept is in fact a abstraction transformationexpression viewelement sumelement view ressioninocl figure transformation dependency reused from the uml but with additional plays the key role in relating elements from the sum to elements of a abstraction is actually mapped to when appearing in the equals sign links elements in the sum to the respective elements in the and vice for ity of the general of a generalization in a transformation invariant means when following there must be an element in the sum and in the view for which similar transformation expressions are in the case of kobra which has many projections that just select a subset of elements using this allows concise declarative together with the view a case tool can be implemented which uses a transformation language of the for instance the atlas transformation language or qvt the role names se and ve are short for sumelement and these roles subset the client and supplier roles from the sum elements are translated into uml elements with so that the views are easy to manage for velopers familiar with the the bidirectional mappings between stereotyped view elements and sum elements are expressed in the constraints of the a subclass of the abstraction from the allviews this is also an example of a transformation which is reused in other context associationabstraction navigableownedend navigableownedend implies hasstereotype hasstereotype implies ocliskindof implies hasstereotype nests hasstereotype implies ocliskindof ocliskindof implies hasstereotype hasstereotype implies ocliskindof figure shows the main elements involved in the formation of the black box structural view for the \ufb01rst transformation constraint is on the view and declares the starting point for the it states that the subject componentclass and its tions a sum utility are in the the following transformation rules illustrate how to create the output elements from the input such as the publicly visible attributes and operations of the componentclass and the acquired the \ufb01rst constraint for componentclassabstraction states that references to potential general classes of componentclasses are mirrored in the in componentclasses will be shown with the sponding the componentclass owns various types of so in this view only the acquires ciations are selected transformation rules are ered in the common transformation classes and only publicly visible attributes and operations appear in the class invariants are also classes that may appear in this view as alizations of may have a powertype name which will be the last transformation statement copies the class ences of as with all the transformation the common transformation statements also cover and the view constraints serve as a \ufb01cation for the implementation of a individual case tools can use di\ufb00erent implementation techniques as long as they conform to the semantics of these rules and componentclassabstraction operationabstraction classabstraction figure transformation to the speci\ufb01cation structural service context views subject specificationstructuralclassservice ownedmember superclosure context componentclassabstraction superclass hasstereotype implies hasstereotype and ocliskindof association ocliskindof context classabstraction ownedattribute visibility ownedoperation visibility copy powertypeextent that is only allowed for class powertypeextent powertypeextent context operationabstraction for the black box type only publicly visible tributes and operations of classes opposed to used by the subject can be this is i\ufb01ed in the \ufb01rst rule which de\ufb01nes owned members of the view and thus serves as the starting point of the cbbtypes is a utility function de\ufb01ned in the sum which computes the black box types by selecting the types of the public attributes and parameter types of its public class invariants and potential powertypes and connections to the classes in this view are shown as there may also be for which the enumerationliterals are the transformation rules for this view are almost the same as the realization transformation constraints from the age the di\ufb00erences are the statements for operations and context views subject specificationstructuralclasstype ownedmember or or ocliskindof subject context componentclassabstraction implies hasstereotype context classabstraction not componentclass implies ownedattribute visibility ownedoperation visibility powertypeextent powertypeextent superclass context componentclassabstraction implies hasstereotype context enumerationabstraction ownedliteral ownedliteral context enumerationliteralabstraction specification specification stringinsignature navigation most of tools use some combination of trees to organize the content of models as well as the views used to visualize a software system or in an any ronment incorporating a number of di\ufb00erent tools there is invariably a large number of di\ufb00erent trees storing a erogeneous mix of artifacts including model elements diagrams class state and other artifact types xml con\ufb01guration \ufb01les to work with all the views in a traditional development engineers typically have to learn about the organization structures of all the incorporated in contrast to conventional paradigms for organizing and navigating the many views used to visualize a osm employs the metaphor of a more as illustrated in figure osm regards sion of the underlying methodology as representing a ent dimension of the and each independently variable aspect of that dimension is a selectable dimension selecting a view thus simply corresponds to selecting a single cell within the in three types of dimensions are static dimensions in which the number of figure selectable elements is dynamic mensions in which the number of elements is dynamic derived from the and mixed dimensions which have both static and dynamic to support the osm dimension based navigation metaphor for we de\ufb01ned the seven dimensions indicated on the left hand side of figure which is a sceenshot of the abstraction dimension expanded which has three static dimension pim independent psm speci\ufb01c and captures the development concern of the sion dimension captures the state of the modeled system at speci\ufb01c points in the component which has dynamic dimension elements de\ufb01ned by instances of the class componentclass in the captures the based development concern of the encapsulation which has two \ufb01xed supports the distinction between speci\ufb01cation and realization views of while the projection dimension with the \ufb01xed elements operational and behavioral covers the di\ufb00erent information the granularity dimension provides a \ufb01ner grained distinction between views describing the types used by ponents and views describing the required and provided interfaces the tion dimension allows a selection of individual in the ideal when all views are truly the choices that can be made in each dimensions are completely this is very di\ufb03cult to achieve in software the approach still works if the views are not completely but dependencies then occur between di\ufb00erent choices in di\ufb00erent so that the decisions made in one dimensions may a\ufb00ect choices ble in another this is best handled by giving dimensions a precedence ranking determined by the order in which they appear top being the when an element in a dimension is the tool automatically makes default selections for dimensions of lower precedence dimensions lower and disables selections that would navigate to cells which are not \ufb01ned by the method at shopping cart example to show how a software system can be speci\ufb01ed using this section presents a case study based on a ping cart a shoppingcart component collects and figure speci\ufb01cation structural manages the products selected by users and supports ment via a credit figure illustrates a structural view of the in the dimension navigator on the left hand pim was chosen for the expanded in the the second dimension is the state of the ware system at a certain point in the picture shows that the latest available version was as with every choice in a it may in\ufb02uence the options in lower ranked the component under consideration is the for which a black box view is selected in the next after the user selects the structural projection option and the service level the tool automatically chooses the option for all operations in the last as there is no editor registered for the other the component under development is presented with the stereotype subject and its relationship to other components and classes is shown in the which corresponds to a cell of the navigation and is generated from the sum when it is the classes product and creditcard can be used as data types in the operations of the figure illustrates the operational view in which an operation can be formalized using and the precondition corresponds to the assumes clause in and the postcondition corresponds to the result as in the the precondition of an operation must be true when the operation is invoked and the postcondition must be true when the operation is the operation addproduct in figure must be in state collectingproducts or empty when this is also visible in the behavioral figure operation since there are only two transitions with the operation both leads to the state collectingproducts which is also a postcondition of the the second condition is that the cost attribute of the component must be increased by the price of the added the and postcondition can be expressed using the the ties of the states and operation parameters can be used to formalise the constraints like as in this figure shows the publicly visible behaviour of the pingcart component with states and the tional transitions map to operations of the like every this view is also synchronized with the sum so that it is guaranteed that its states and ties are consistent with those in the structural figure speci\ufb01cation behavioral although the operational view seems to be similar to the behavioral view because of the overlapping information within there are signi\ufb01cant the focus of the erational view is on a precise formal de\ufb01nition of an tion of a the operations can be enriched by and postconditions which can be de\ufb01ned using complex ocl that formalize the complete behavior of an the additional information in the ocl statements can be used for code generation and conclusion at the beginning of the paper we identi\ufb01ed three mental hypothesis upon which the notion of osm is based that it is feasible to integrate the many di\ufb00erent kinds of artifacts used in contemporary software engineering ods within a single coherent methodology in which they are treated as that it is feasible to create an cient and scalable way of supporting these views by ating them from a single ing model using transformations and that it is feasible to provide an intuitive metaphor for navigating around these many views by adapting the graphic projection technique underpinning the cad tools used in other engineering the prototype described in this paper resents the \ufb01rst step towards demonstrating the validity of these hypotheses and showing that osm is a viable approach to software of the three and are most convincingly demonstrated by the since it shows that it is indeed possible to support all the views of the kobra method within a single navigation the prototype tool does not demonstrate the validity of pothesis to the same extent as the others due to its small although it demonstrates the feasibility of erating views from the sum and the question of whether such an approach scales up to large environments is still although noami is the only tool developed with the ci\ufb01c aim of supporting several other tools and methods have similar properties or for glinz et describe a tool with a \ufb01sheye zooming algorithm which lets the user view a model with varying amounts of detail depending on the it has to be investigated whether it is possible to combine the eye zooming concept with the navigation while the kobra implementation of naomi heavily uses uml diagrams for glinz et use custom diagram for structural and behavioral an approach which also emphasizes the description of mal consistency rules between views is this approach does not itly mention the notion of a sum and thus implies that consistency rules should be de\ufb01ned in a pairwise fashion tween individual pairs of archimate which plements togaf is an enterprise architecture eling language which o\ufb00ers two orthogonal for and layers and behavioral and aspects and also suggests two more purpose and abstraction as many of these views span multiple choices of a the intuitive navigation metaphor of osm can not be easily there are also more general approaches for modeling but they are less speci\ufb01c in terms of consistency rules between views and provide little guidance on how to manage and navigate for example the zachman framework regarding the practical use of osm environments in the the biggest challenge is developing appropriate sum metamodels which can accommodate all the types of views and services that software engineers are accustomed to for this \ufb01rst prototypical environment porting the osm approach we had a method at our disposal that already de\ufb01ned a full set of orthogonal based this allowed us to model the required sum and view metamodels by simply adapting the uml removing and adding model elements as in doing so we were able to manually ensure that the models ful\ufb01lled the two core requirements of vironments being minimalistic and redundancy if software engineering environments are to take and to be introduced into neous more sophisticated ways of integrating existing metamodels into a single uni\ufb01ed metamodel will be",
    "references": [
        "[1] C. Atkinson, J. Bayer, C. Bunse, E. Kamsties, O. Laitenberger, R. Laqua, D. Muthig, B. Paech, J. Wust, and J. Zettel. ComponentBased Product Line Engineering with UML. Addison Wesley, Reading, Massachusetts, USA, 1st edition, November 2001. ",
        "[2] C. Atkinson, D. Stoll, and P. Bostan. Orthographic Software Modeling: A Practical Approach to ViewBased Development. In Evaluation of Novel Approaches to Software Engineering, volume 69 of Communications in Computer and Information Science, pages 206219. Springer Berlin Heidelberg, 2010. ",
        "[3] C. Atkinson, D. Stoll, and C. Tunjic. Orthographic Service Modeling. In Proceedings of 15th IEEE EDOC Conference Workshops (EDOCW), Helsinki, Finland, 2011. ",
        "[4] Eclipse Foundation. UML2Tools. http://wiki.eclipse.org/MDTUML2Tools, 2013. ",
        "[5] ISO/IEC and ITUT. The Reference Model of Open Distributed Processing. RMODP, ITUT Rec. X.901X.904 / ISO/IEC 10746. http://standards.iso.org/ ittf/PubliclyAvailableStandards/index.html, 1998. ",
        "[6] J. I. J. Jose Raul Romero and A. Vallecillo. Realizing Correspondences in MultiViewpoint Speci\ufb01cations. In Proceedings of the Thirteenth IEEE International EDOC Conference, 1 4 September 2009, Auckland, New Zealand, September 2009. ",
        "[7] M. Lankhorst. Enterprise Architecture at Work. Springer Berlin Heidelberg, 2009. ",
        "[8] Object Management Group (OMG). OMG Uni\ufb01ed Modeling Language (OMG UML), Superstructure, V2.1.2. http://www.omg.org/cgibin/doc?formal/071102, November 2007. ",
        "[9] Object Management Group (OMG). Meta Object Facility (MOF) 2.0 Query/View/Transformation, v1.0. http://www.omg.org/spec/QVT/1.0/PDF/, April 2008. ",
        "[10] C. Seybold, M. Glinz, S. Meier, and N. MerloSchett. An e\ufb00ective layout adaptation technique for a graphical modeling tool. In Proceedings of the 2003 International Conference on Software Engineering, Portland, 2003. ",
        "[11] The Atlas Transformation Language (ATL). O\ufb03cial Website. http://www.eclipse.org/atl/, 2013. ",
        "[12] The Open Group. TOGAF Version 9 The Open Group Architecture Framework. http://www.opengroup.org/architecture/ togaf9doc/arch/index.html, Feb 2009. ",
        "[13] University of Mannheim Software Engineering Group. nAOMi opeN, Adaptable, Orthographic Modeling EnvIronment. http://eclipselabs.org/p/naomi. ",
        "[14] J. A. Zachman. The Zachman Framework: A Primer for Enterprise Engineering and Manufacturing. http://www.zachmaninternational.com, 2009."
    ]
}