{
    "url": "dummy",
    "title": "Towards a Quantum Software Modeling Language",
    "authors": [
        "Carlos A. P\u00e9rezDelgado",
        "Hector G. PerezGonzalez"
    ],
    "institutes": [
        "University of Kent Canterbury, Kent, United Kingdom",
        "Universidad Aut\u00f3noma de San Luis Potos\u00ed San Luis Potos\u00ed, SLP, M\u00e9xico"
    ],
    "keywords": [
        "quantum computing",
        "software engineering",
        "UML"
    ],
    "abstract": "We set down the principles behind a modeling language for quantum software. We present a minimal set of extensions to the well known Unified Modeling Language (UML) that allows it to effectively model quantum software. These extensions are separate and independent of UML as a whole. As such they can be used to extend any other software modeling language, or as a basis for a completely new language. We argue that these extensions are both necessary and sufficient to model, abstractly, any piece of quantum software. Finally, we provide a small set of examples that showcase the effectiveness of the extension set.",
    "content": "introduction quantum computation rose to prominence after the discovery of quantum that can efficiently perform tasks that are intractable these discoveries propelled research and interest in quantum there exists prototype quantum hardware with computational capabilities beyond that of any classical further applications of quantum theory to computation have also been made in several areas of theory of such as models of data and quml before discussing in depth the extensions we are we make a few fundamental observations on which we base the guiding principles for our extension our first observation is about the nature of quantum the central difference between quantum and classical computation is in how it achieves its quantum computers have access to quantum and quantum data that are unavailable to classical computers hence their performance algorithms and data structures implementation algorithms are an essential design choice while programming in the they are more often than not completely ignored in software architectural for uml diagrams seldom portray algorithms and data structures beyond a very design it would seem then that quantum computation introduces nothing to computation that needs to be captured in a software design this is not the and the reason for this is our second quantum computation changes the very nature of information quantum information is much richer than classical it is also much more challenging to and if a module needs to transmit or receive quantum then this is an important design consideration which needs to be included in any effective software a third observation here is that the classical quantum nature of the information used by a module is an important consideration both when discussing its internal implementation and its these two are separate and independent a classical implementing some classical would have no or to communicate quantum a quantum module may or may not have a quantum behavior may be completely part of its internal and not appear as part of its for take a module implementing algorithm uses quantum effects to efficiently factor a large integer into its prime the implementation of this module must necessarily be both the input large and the output prime consist of classical and the interface of such a module can be strictly more we can conceive of quantum software modules that have all classical inputs and outputs the above all quantum inputs and or a mix of a quantum ware design must for each individual interface whether it is classical or if it is in whether a module communicates classically or via quantum and whether its internal implementation requires quantum hardware are important considerations that need to be captured in a design the importance of such labelling should be quantum data can only be stored and transmitted with special hardware designed to do more from an strictly software quantum and classical information are not classical information is and admits fanout while quantum information does on the other quantum information has a much larger it is true that quantum information is strictly a of classical hence a quantum module can nicate any classical information it desires using a quantum interface we that using a quantum interface ment and messaging when classical would suffice is bad quantum software for the reasons stated in the guiding principles behind any quantum software modeling language must include the whenever a software module makes use of quantum either as part of its internal or as part of its this must be clearly established in a design each module interface element public public and internal state variables can be either classical or and must be labelled each variable should be labelled as classical or if the model represents data the variables should also specify the classical or quantum qubit quantum graph data for each both the put and output should be clearly labelled as either classical or whether the operation internally operates quantumly should also be a module that has at least one quantum element is to be considered a quantum software otherwise it is a classical quantum and classical modules should be clearly labelled as any module that is composed of one or more quantum modules will itself be considered a quantum and must be labelled as quantum and classical ules can communicate with each other as long as their faces are the quantum module has classical inputs outputs that can interface with the classical we will argue in how these extensions are not only but also sufficient in order to design and represent quantum in the following two sections we put these principles into practice as a set of concrete extensions to class diagram extensions uml is a very graphical meant to convey a lot of meaning in a very small amount of as it makes sense to use a graphical way to represent quantum software we chose to do this by use of bold text to denote quantum and double lines to denote a quantum relationship or quantum figure class diagram of tum classes and interface elements are presented in bold and quantum relationships use for the name will be bold if it is represented using quantum for we use the following if any of the inputs are these are if the output or datatype of the method is then the datatype should also be for backwards compatibility with regular whenever the input or output datatypes of a method are these will be assumed to be classical in if a has any quantum attributes or methods then it itself is considered and its name shall also be relationships between classes will use whenever the relationship is quantum in for if the superclass is quantum then the and the inheritance will also be converse is not necessarily true in the case of aggregation and if a being is then the to which it is as well as that relationship will also be association relationships do not have any special beyond the need of a quantum to have a classical interface if it is to associate with classical showcases a diagram that exemplifies the above sequence diagram extensions sequence diagrams in uml allow us to portray the dynamic tionship between modules in a software as we did before for static we extend the existing language in order to allow us to differentiate between classical and quantum as previously this is essential quantum information behaves differently from classical it can different it admits different it requires different hardware to and figure sequence diagram of quantum classes are presented in bold and quantum messages use like we make use of bold text to markup quantum and double lines to portray quantum shows a sequence note how even though the relationship between shorfactor and shororder is the messaging between them is this illustrates an important a module is marked as quantum if it uses quantum resources in any either directly as part of its internal implementation or as part of an aggregated if a uml a composed class or is then the encompassing module must also be marked as in a static the quantum composition relationships inform in the case of a seemingly classical module that does not in itself use quantum composed modules are using quantum note the communication between the objects shororder and the module operates on a quantum both messages are the return sages \u03c1 and are quantum the request to perform a quantum fourier transform or a qft inverse operation can therefore be communicated this gram showcases the level of granularity available to us using these diagrams with the proposed discussion we have proposed a minimal series of extensions to existing ware modeling we exemplify our additions in but these extensions are easily applicable to any other modeling or be used as the basis for a new modeling argued the necessity of each of the extensions in previous we can argue as that these extensions are not only but also sufficient to fully model quantum to make this we appeal to the fact that all quantum computation is simulable using classical computation albeit with an efficiency other than their use of quantum information and quantum computers are indistinct from classical from a design the only information element that needs to be considered when developing quantum software is when quantum than information is being the one remaining information element we have not discussed is algorithm if quantum computation is to be it will most likely be due to the efficient algorithms at its that algorithm efficiency is not a solely quantum uml itself does not inherently have language elements for algorithm efficiency it have several extensions used and proposed for this other modeling languages may also have definite algorithm efficiency we argue that it is best to use existing language elements when they are acknowledgments would like to acknowledge funding through the epsrc tum communications hub the authors would also like to thank joanna ziembicka for useful comments during the preparation on this",
    "references": [
        "[1] Frank Arute et. al. 2019. Quantum supremacy using a programmable supercon ducting processor. Nature 574, 7779 (2019), 505510. https://doi.org/10.1038/ s4158601916665 ",
        "[2] Charles H Bennett and Gilles Brassard. 2014. Quantum cryptography: public key distribution and coin tossing. Theor. Comput. Sci. 560, 12 (2014), 711. ",
        "[3] Grady Booch, James Rumbaugh, and Ivar Jacobson. 2005. Unified Modeling Lan guage User Guide, The (2nd Edition) (AddisonWesley Object Technology Series). AddisonWesley Professional. ",
        "[4] C. Canevet, S. Gilmore, J. Hillston, M. Prowse, and P. Stevens. 2003. Performance modelling with the Unified Modelling Language and stochastic process algebras. IEE Proceedings Computers and Digital Techniques 150, 2 (March 2003), 107120. https://doi.org/10.1049/ipcdt:20030084 ",
        "[5] Lov K. Grover. 1996. A Fast Quantum Mechanical Algorithm for Database Search. In Proceedings of the Twentyeighth Annual ACM Symposium on The ory of Computing (STOC 96). ACM, New York, NY, USA, 212219. https: //doi.org/10.1145/237814.237866 ",
        "[6] Carlos A. P\u00e9rezDelgado and Donny Cheung. 2007. Local unitary quantum cellular automata. Phys. Rev. A 76 (Sep 2007), 032320. Issue 3. https://doi.org/10.1103/ PhysRevA.76.032320 ",
        "[7] Peter W Shor. 1994. Algorithms for quantum computation: Discrete logarithms and factoring. In Proceedings 35th annual symposium on foundations of computer science. Ieee, 124134. ",
        "[8] Liming Zhao, Carlos A. P\u00e9rezDelgado, and Joseph F. Fitzsimons. 2016. Fast graph operations in quantum computation. Phys. Rev. A 93 (Mar 2016), 032314. Issue 3. https://doi.org/10.1103/PhysRevA.93.032314 444"
    ]
}