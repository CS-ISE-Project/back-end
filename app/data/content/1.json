{
    "info": {
        "title": "AI Model for Computer games based on Case Based Reasoning and AI Planning",
        "authors": [
            "Vlado Menkovski",
            "Dimitrios Metafas"
        ],
        "institutes": [
            "Athens Information Technology"
        ],
        "keywords": [
            "Game AI",
            "Case Based Reasoning",
            "AI Planning",
            "Game Trees"
        ],
        "abstract": "Making efficient AI models for games with imperfect information can be a particular challenge. Considering the large number of possible moves and the incorporated uncertainties building game trees for these games becomes very difficult due to the exponential growth of the number of nodes at each level. This effort is focused on presenting a method of combined Case Based Reasoning (CBR) with AI Planning which drastically reduces the size of game trees. Instead of looking at all possible combinations we can focus only on the moves that lead us to specific strategies in effect discarding meaningless moves. These strategies are selected by finding similarities to cases in the CBR database. The strategies are formed by a set of desired goals. The AI planning is responsible for creating a plan to reach these goals. The plan is basically a set of moves that brings the player to this goal. By following these steps and not regarding the vast number of other possible moves the model develops Game Trees which grows slower so they can be built with more feature moves restricted by the same amount of memory."
    },
    "sections": {
        "1. Introduction": "The goal of this effort is to explore a model for design and implementation of an AI agent for turn based games. This model provides for building more capable computer opponents that rely on strategies that closely resemble human approach in solving problems opposed to classical computational centric heuristics in game AI. In this manner the computational resources can be focused on more sensible strategies for the game play. With the advancement in computer hardware increasingly more computing power is left for executing AI algorithms in games. In the past AI in games was mainly a cheating set of instructions that simulated the increasing difficulty in the game environment so that the player had the illusion of real counterpart. Improvement in available memory and processing power allows implementation of more intelligent algorithms for building the game environment as well as direct interaction with the human players. In this particular research the emphasis is put on the interaction between the AI agent and a computer player in the realm of the game rules. It is particularly focused on turn based games that have the elements of uncertainty like dice or concealed information. At the beginning a description of Game AI algorithms are given; such as Game Trees and Minimax. The following section describes an approach of using AI Planning to improve building Game Trees in games with imperfect information where Game Trees tend to be very large with high growth ratio. Section 4 discusses another approach that provides a significant reduction to the number of considered moves in order to find the favorable strategy of the AI player. This approach uses AI Planning techniques and Case Base Reasoning (CBR) to plan for different scenarios in predetermined strategies which would be analogous to human player experience in the particular game. The CBR database illustrates a set of past experiences for the AI problem and the AI Planning illustrates the procedure to deal with the given situation in the game. In the next two sections implementations and evaluations of both approaches are given. The AI Planning approach is implemented with the Tictactoe game and the combined AI Planning and CBR approach is implemented with a model for the Monopoly game. The last part contains conclusions and future work ideas.",
        "2. Game Trees and Minimax": "Game Trees are common model for evaluating how different combinations of moves from the player and his opponents will affect the future position of the player and eventually the end result of the game. An algorithm that decides on the next move by evaluating the results from the built Game Tree is minimax [1]. Minimax assumes that the player at hand will always choose the best possible move for him, in other words the player will try to select the move that maximizes the result of the evaluation function over the game state. So basically the player at hand needs to choose the best move overall while taking into account that the next player(s) will try to do the same thing. Minimax tries to maximize the minimum gain. Minimax can be applied to multiple levels of nodes on the game tree, where the leaves bring the final known (or considered) game state. The minimax theorem states: For every twoperson, zerosum game there is a mixed strategy for each player, such that the expected payoff for both is the same value V when the players use these strategies. Furthermore, V is the best payoff each can expect to receive from a play of the game; that is, these mixed strategies are the optimal strategies for the two players. This theorem was established by John von Neumann, who is quoted as saying \"As far as I can see, there could be no theory of games without that theorem I thought there was nothing worth publishing until the Minimax Theorem was proved\" [2]. A simple example of minimax can be observed by building a game tree of the tictactoe game. The tictactoe game is a simple game which can end by the first player wining, the second player wining or a tie. There are nine positions for each of the players in which at each turn the player puts X or O sign. If the player has three adjacent signs in a row, column or the two diagonals he or she wins. This game has limited number of position and it is well suited for building the whole game tree. The leaves of this tree will be final positions in the game. A heuristics evaluation function will also need to be written to evaluate the value of each node along the way.",
        "3. AI Planning for building Game Trees": "",
        "3.1.1 AI Planning": "AI Planning also referred as Automated Planning and Scheduling is a branch of Artificial Intelligence that focuses on finding strategies or sequences of actions that reach a predefined goal [3]. Typical execution of AI Planning algorithms is by intelligent agents, autonomous robots and unmanned vehicles. Opposed to classical control or classification AI Planning results with complex solutions that are derived from multidimensional space. AI Planning algorithms are also common in the video game development. They solve broad range of problems from path finding to action planning. A typical planner takes three inputs: a description of the initial state of the world, a description of the desired goal, and a set of possible actions. Some efforts for incorporating planning techniques for building game trees have also shown up, similar to the approach explored in this effort. In addition Cased Based Reasoning [4] techniques are also gathering popularity in developing strategies based in prior knowledge about the problems in the games. One of the benefits from Hierarchical Task Network (HTN) [5] planning is the possibility to build Game Trees based on HTN plans; this method is described in the following section.",
        "3.2 Game Trees with AI Planning": "An adaptation of the HTN planning can be used to build much smaller and more efficient game trees. This idea has already been implemented in the Bridge Baron a computer program for the game of Contact Bridge [6]. Computer programs based on Game Tree search techniques are now as good as or better than humans in many games like Chess [7] and checkers [8], but there are some difficulties in building a game tree for games that have imperfect information and added uncertainty like card or games with dice. The main problem is the enormous number of possibilities that the player can choose from in making his move. In addition some of the moves are accompanied with probabilities based on the random elements in the games. The number of possible moves exponentially grows with each move so the depth of the search has to be very limited to accommodate for the memory limitations. The basic idea behind using HTN for building game trees is that the HTN provides the means of expressing high level goals and describing strategies how to reach those goals. These goals may be decomposed in goals at lower level called subgoals. This approach closely resembles the way a human player usually addresses a complex problem. It is also good for domains where classical search for solution is not feasible due to the vastness of the problem domain or uncertainties.",
        "3.2.1 Hierarchical Task Networks": "The Hierarchical Task Network, or HTN, is an approach to automated planning in which the dependency among actions can be given in the form of networks [9] [Figure 1]. A simple task network (or just a task network for short) is an acyclic digraph in which U is the node set, E is the edge set, and each node contains a task . The edges of define a partial ordering of U. If the partial ordering is total, then we say that is totally ordered, in which case can be written as a sequence of tasks . Figure 1: Simple Hierarchical Task Network A Simple Task Network (STN) method is a 4tuple of its name, task, precondition and a task network. The name of the method lets us refer unambiguously to substitution instances of the method, without having to write the preconditions and effects explicitly. The task tells what kind of task can be applied if the preconditions are met. The preconditions specify the conditions that the current state needs to satisfy in order for the method to be applied. And the network defines the specific subtasks to accomplish in order to accomplish the task. A method is relevant for a task if the current state satisfies the preconditions of a method that implements that task. This task can be then substituted with the instance of the method. The substitution is basically giving the method network as a solution for the task. If there is a task Go home and the distance to home is 3km [Figure 2] and there exists a method walkto and this method has a precondition that the distance is less than 5km, then a substation to the task Go home can be made with this method instance. Figure 2: HTN Method Buy milk Go to (shop) Purchase Go to (home) Goto (from, to) Walk (to) If (to from) 5km 296 DIMEA 2008 3rd International Conference on Digital Interactive Media in Entertainment and Arts If the distance is larger than 5km another meth to be substituted [Figure 3]. Figure 3: HTN Method 2 An STN planning domain is a set of operatio methods M. A STN planning problem is a 4tu state S0, the task network w called initial task STN domain. A plan is a soluti problem if there is a way to decompose w into \u03c0 and each decomposition is applicable in the ap the world. The algorithm that is capable to networks into plans is called Totalforwarddeco [9] or Partialforwarddecomposition (PFD). H cases where one does not want to use a forwa procedure. HTN planning is generalization of S gives the planning procedure more freedom construct the task networks. In order to provide this freedom, a bookke is needed to represent constraints that the plann not yet enforced. The bookkeeping is done by unenforced constraints explicitly in the task netw The HTN generalizes the definition of a STN. A task network is the pair w task nodes and C is a set of constraints. Eac specifies a requirement that must be satisfied by a solution to a planning problem. The definition of a method in HTN also definition used in STN planning. A HTN pla name, task, subtasks, and constraints. The s constraints form the task network. The HTN plan identical to STN planning domains except they u instead of STN methods. Compared to classical planners the prim HTN planners is their sophisticated knowledge r reasoning capabilities. They can represent and nonclassical planning problems; with a good guide them, they can solve classical planning p magnitude more quickly than classical or neoc The primary disadvantage of HTN is the nee author to write not only a set of planning opera of methods.",
        "3.2.2 HTN Planning in building Game": "For a HTN planning algorithm to be adap trees we need to define the domain (set of H operators) which is the domain of the game. Thi a knowledge representation of the rules of the environments and possible strategies of game pla In this domain the game rules as well as kn tackle specific task are defined. The implem Tree building with HTN is called Tign implementation uses a procedure simila decomposition, but adapted to build up a game Drive(to If(t Goto (from, to) If(to from) 5km Walk (to) hod instance needs ons O and a set of uple of the initial k network and the ion for a planning \u03c0 if \u03c0 is executable ppropriate state of decompose these omposition (TFD) However there are arddecomposition STN planning that m about how to eeping mechanism ning algorithm has y representing the work. a task network in where is a set of h constraint in C y every plan that is o generalizes the an is a 4tuple of subtasks and the nning domains are use HTN methods mary advantage of representation and solve a variety of d set of HTNs to problems orders of classical planners. ed of the domain ators but also a set Trees ted to build game HTN methods and is is in some sense e game, the game ay. nown strategies to mentation of Game num2 [9]. This ar to forward tree rather than a plan. The branches of the game tree rep the methods. Tignum2 applies all met state of the world to produce new continues recursively until there are n have not already been applied to th world. In the task network generated by Tignu actions will occur is determined by th By listing the actions in the order network can be serialized into a gam",
        "4. Case Based Reasoning in": "",
        "4.1 Case Based Reasoning": "Casebased reasoning (CBR) is a Artificial Intelligence (AI), both as problems and as a basis for standalone Casebased reasoning is a paradigm solving and learning that has became applied subfield of AI of recent yea intuition that problems tend to recur. I are often similar to previously en therefore, that past solutions may be of [10]. CBR is particularly applicable to probl available, even when the domain is n for a deep domain model. Helpdesks, systems have been the most successfu to determine a fault or diagnostic attributes, or to determine whether or repair is necessary given a set of past s Figure 5: Game Tree built fr Figure 4: HTN to Game Tr ) to from) 200km present moves generated by thods applicable to a given w states of the world and no applicable methods that he appropriate state of the um2, the order in which the e totalordering constraints. they will occur, the task me tree [Figure 4] [Figure 5]. n Game Strategies well established subfield of a mean for addressing AI AI technology. m for combining problem one of the most successful ars. CBR is based on the It means that new problems ncountered problems and, f use in the current situation lems where earlier cases are not understood well enough , diagnosis or classification ul areas of application, e.g., an illness from observed r not a certain treatment or olved cases [11]. rom HTN ree Algorithm Interactive and Adaptable Media 297 3rd International Conference on Digital Interactive Media in Entertainment and Arts Central tasks that all CBR methods have to deal with are [12]: \"to identify the current problem situation, find a past case similar to the new one, use that case to suggest a solution to the current problem, evaluate the proposed solution, and update the system by learning from this experience. How this is done, what part of the process that is focused, what type of problems that drives the methods, etc. varies considerably, however\". While the underlying ideas of CBR can be applied consistently across application domains, the specific implementation of the CBR methods in particular retrieval and similarity functions is highly customized to the application at hand.",
        "4.2 CBR and Games": "Many different implementations of CBR exist in games. CBR technology is nicely suited for recognizing complex situations much easier and more elegant than traditional parameter comparison or function evaluation. There are especially evident cases in real time strategies where different attack and defense of global strategies are nicely defined by CBR datasets and later used in the running games. Also intelligent bots behavior is also another typical example. Depending on the number of enemy bots the layout of the terrain and position of human players the CBR system finds the closest CBR case and employs that strategy against the human players which in prior evaluation was proved to be highly efficient.",
        "5. Game Trees with AI Planning Tictactoe": "In order to show the expressive power of AI Planning in defining strategies for games, and the use of these plans to build Game Trees I implemented an algorithm that builds Game Trees for the TicTacToe game. The game tree of TicTacToe shows 255,168 possible games of which 131,184 are won by X (the first player), 77904 are won by O and the rest 46,080 are draw [13]. All these games can be derived from building a complete Game Tree. Even though it is possible to build a complete game tree of Tictactoe it is definitely not an optimal solution. Many of the moves in this tree would be symmetrical and also there are a many moves that would be illogical or at least a bad strategy to even consider. So what strategy should X (the first player) choose in order to win the game? There are few positions that lead to certain victory. These positions involve simultaneous attack on two positions so the other player could not defend, basically the only trick in TicTac Toe. Figure 6: Tictactoe winning strategy positions Position 1 leads to victory if the two of the three fields: top middle, bottom left corner and bottom right corner are free [Figure 6]. Position 2 lead to victory if two of the three fields: top right corner, bottom right corner and bottom middle are free [Figure ]. And in the third position if the two of center, middle top and middle left are available the position is a certain victory. There are many different arrangements of the players tokens that give equivalent positions as these three positions. By using planning we do not need to consider all possible layouts but just consider these three similar to what a human would consider. The game starts from an empty table. The two relevant strategies that would lead to these positions are to take one corner or to take the center [Figure 7]. Figure 7: Tictactoe Two starting moves The center position as we can see in the simulation results lead to a bigger number of victorious endings but it is also a straight forward strategy with obvious defense strategy. At this point we need to consider the moves of the opponent. If we take the left branch the opponent moves can be a center, a corner or a middle field. We also need to differentiate with a move to a corner adjacent with our like top left or bottom right or across the center to bottom right [Figure 8]. Figure 8: Tictactoe opponent response to corner move In cases one and two, we have a clear path to executing strategy 3 so we need to capture the diagonally opposite field. And as for the third case the best way to go is to capture the center and go for strategy 1 or 2 depending of the opponents next move. Figure 9: Tictactoe move 2 after corner opening The first move leads to certain victory, O will have to go to the center and X will achieve strategy 3 [Figure 9]. The second move is a possible way to strategy 3 if O makes a mistake in the next loop, so X goes to the opposite corner. For the third case since O is playing a valid strategy the only move that leaves a possible mistake from O would be to take the center and wait for O to go to the middle and then achieve strategy 1 or 3 which will be a symmetric situation to the one that we will find if we branched with the center. Figure 10: Tictactoe opponent response to center move If we go back to the second branch [Figure 10], a possible way for the second player to engage is corner or middle. The first 298 DIMEA 2008 3rd International Conference on Digital Interactive Media in Entertainment and Arts move is a valid strategy for O and can be mee corner move from X to try a mistake from O in the same as in the third case above from the pre another move would be go to the middle wh achieves strategy 1 or 2. Figure 11: Tictactoe Move 2 after cent The fist move will lead to win if O moves draw if it goes for the corners [Figure 11]. In t has to block the lower left corner which leave middle left or corner left which are strategy 1 and To sum the strategies for the planning, first corner strategy for the beginning. Then for the ce the corners with the particularly the one oppo holds. If the center is empty for the second strate we go for the opposite corner. After this point w opponent or try to implement strategies 1, 2 or victory. Plan 1: Take center Preconditions: Center empty Plan 2: Take corner Preconditions: All corners empty Plan 3: Take corner after center Preconditions: We have center take corner oppos opponent has Plan 4: Take diagonal corner Preconditions: We have a corner, the opponent ha the corner opposite to the one we have is free. Plan 5: Block Precondition: The opponent has tree tokens in a r agonal Plan 6: Win Preconditions: We have two tokens in a row, colu nd the third place is free Plan 7: Tie Preconditions: If all places are taken, its a tie.",
        "5.1 Hierarchical Task Network": "Top level task is Play [Figure 12]. This is a can be derived into: Win, Block, Tie or Sear Search for plan is derived to both Plan 1 and Pla Plan 4, which later leads to a call for the oppon recursive call to Play. Figure 12: Tictactoe HT et with a opposite the future exactly evious branch, and here X eventually ter opening to the middle or a the second case O es X to go for the d 2. we have center or enter we try to get osite to the one O egy we go for it or we either block the r 3 which lead to site to the one the as the center and row, column or di mn or diagonal a a complex task and rch for Plan. The an 2 or Plan 3 and nents move and a TN This HTN when executed will re game scenarios. By creating nodes from them with branches with the move of t tree for the Tictactoe game over whi algorithm. This set up with 7 plans with 3 ta for Tictactoe which considers all pos player with only 457 games, 281 of w and 0 where the second opponent w reduction over the 255, 168 possible g tree. These reductions can be very use computing capabilities but also we pr that planning can be very efficient if d trees by applying reasoning very reasoning. Further improvements to the gam the opponents moves are also planned all the meaningless and symmetrical m",
        "6. Game AI in Monopoly": "",
        "6.1 Overview of the AI Imp": "The AI agent is responsible for players in the game. The core principle a Game Tree with all the sensible move make from the current point of time minimax algorithm the agent selects t would bring the computer player mo with the highest probability. Building that would be big enough to consider is obstructed by the vastness of poss with all the possible random landings nodes of the game tree exponentially tackle this problem the AI agents discussed technologies: Case Based Re The technologies are employed First the agent searches the CBR datab largest similarity with the current state associated with a playing strategy. Th that the planner needs to build plans f consecutive player moves that bring th way only moves that are part of that str being a small fraction of the overall po edges of the game tree at each level dec At each level of the game tree the of a single player. After the strateg considered the response to those strate by the opponent(s). The move of the probability distribution of the dice as player. A more general strategy needs opponents (human player) moves sin the expertise of the opponent. This ge more plausible moves than the focused After covering all opponents t deducting a feature move of the com CBR selected plan strategy. After strategies and reaching a reasonable s into account the memory limits an probabilities that the move is possible the dice the building of the Game Tre algorithm searches the Game Tree favorable move for the AI player usi The process is repeated each time the A esult with plans for possible m each position and linking the player we create a game ich we can run the minimax arget strategies creates a tree ssible moves for the second which X wins 176 are draw wins. This is a significant ames with a complete game eful for devices with limited rove a very important point designing meaningful game similar to human player me tree are also possible if d, in other words if we drop moves of the opponent. plementation the moves of the artificial e of the AI agent is building es that all the players would e forward. Then using the the move that in the future ost favorable game position a Game Tree in this game sufficient number of moves sible moves in combination of the dice. The number of y grows at each level. To incorporates two already easoning and AI Planning. in the following manner. base to find the case with the e of the board. This case is he strategy consists of goal for, and the plans consist of he player to that goal. This rategy are considered, those ossible moves the number of creases immensely. e model considers the moves gies of the AI player are egies needs to be considered opponent(s) depends of the well as the strategy of the s to be implemented for the nce we cannot be aware of eneral strategy would bring d strategy of the AI player. the agent comes back to mputer player by using the creating several loops of size of a Game Tree taking nd the rapidly decreasing e due to the distribution of ee stops. Then the minimax and decides on the most ing the minimax algorithm. AI player is up. Interactive and Adaptable Media 299 3rd International Conference on Digital Interactive Media in Entertainment and Arts Buying, auctioning and trading game moves are always accompanied by return of investment calculations in making the plans. These calculations represent adaptation of the more general planning associated with the cases in the CBR database. These adaptations are necessary due to the fact that the cases do not identically correspond to the situation on the table. In addition calculating the game position value of each node of the game tree is done by heuristic functions that incorporate economic calculations of net present value, cash, and strategic layout and so on. For example railroads in monopoly are known to be strategically effective because they bring constant income even though the income can be smaller than building on other properties.",
        "6.2 Details on the CBR Implementation": "The implementation of the CBR is by using the JColibri2 platform. JColibri2 is an objectoriented framework in Java for building CBR systems that is an evolution of previous work on knowledge intensive CBR [14]. For this implementation we need to look into three particular classes of the JColibri2 platform. The StandardCBRApplication, Connector, CBRQuery. For a JColibri2 implementation the StandardCBRApplication interface needs to be implemented. The CBR cycle executed accepts an instance of CBRQuery. This class represents a CBR query to the CBR database. The description component (instance of CaseComponent) represents the description of the case that will be looked up in the database. All cases and case solutions are implementing the CaseComponent interface. The JColibri2 platform connects to the CBR database via a Connector class. Each connector implements all the necessary methods for accessing the database, retrieval of cases, storing and deletion of cases. This implementation uses a custom XML structure for holding the CBR cases. Since the game will not update the CBR database only read it, a XML solution satisfies the needs. The XML file to a certain extent is similar to the XML representation of the board. We are interested in finding one CBRCase that is the most similar case to the situation in the game at the time of the search. This procedure is done in the cycle method of the CBRApplication. The JColibri2 CBR comparison is done by Nearest Neighbor (NN) search method. JColibri2 offers implementations for NN search algorithms of simple attributes. These implementations are called local similarities. For complex attributes like in our case global customized similarity mechanisms need to be implemented. The MonopolyDescription class [Figure 13] is basically a serialization of the GameState. It holds all the information about the state of the board, the players, their amount of cash etc. Figure 13: Class diagram of the Monopoly Case component models On the other hand the MonopolySolution class holds the three particular attributes that are needed for the planning, the planning Domain, State and TaskList. The game is implemented by using the ModelView Controller software development pattern. The controller is responsible for implementing the game rules and handling all of the events in the game like roll of dice, input commands for trading, auctioning and etc from the players. The View layer is responsible for displaying the board and all of the input widgets on to the game screen, and the models are data structures representing the game state [Figure 14]. Figure 14: Class diagram of the Monopoly models",
        "6.2.1 Complex Similarity representation in CBR": "The similarity measurement part of the Nearest Neighbor algorithm JColibri2 is implemented by implementing the LocalSimiralrityFunction and the GlobalSimiralityFunction interface. A local similarity function is applied to simple attributes by the NN algorithm, and a global similarity function is applied to compound attributes. In the case of our implementation the attributes of the MonopolyDescription are compound attributes describing the state of the board, number of players, amount of cash for every player and etc. Since MonopolyDescription is a custom CaseComponent a global similarity function needs to be implemented to accurately find the distance between different CBR cases. The similarity mechanism is inseparable core element of the CBR system. This mechanism represents how the CBR decides which strategy is best suited for the particular situation by 300 DIMEA 2008 3rd International Conference on Digital Interactive Media in Entertainment and Arts calculating the distance or similarity to other cases in the database. For the monopoly implementation we need to consider several basic strategies. Monopoly is based on investing in properties and receiving revenues from those investments. One of the basic strategies of the game is to build a set of properties that will bring constant income larger than the one of the opponents. So in time the opponents will have to declare bankruptcy. But on the other hand over investment can lead to too stretched resources with low income that will eventually drove the player to bankruptcy. To decide on these two we need a clear separation into two groups of cases in the CBR database. The first group of cases will represent a situation on the board where the player has significant income per loop formed of one or more color group properties, maybe railroads, some buildings on them and so on. It is important to note that in this case the player is better situated than his opponents so he only needs to survive long enough to win the game. In the other group of cases either the opponent is not well positioned on the board or its opponents are better situated. In this case further investments are necessary to improve the situation so the player can have a chance of winning in the long run. These metrics can be owning color groups, valuing groups of railroads, evaluating the other opponents as well, and considering the amount of cash. As it is obvious in monopoly the number of streets is not as nearly as important as the combination of streets the player owns. It is also important to note that one CBR case does not hold only a single strategy in place, but its solution can have multiple different strategic goals. For example one CBR case might simultaneously say buy this land to form a color group but also trade some other unimportant property to increase cash amount. The cases do not represent all possible combinations of board positions. They are only representation of typical game scenarios. The CBR Case solutions do not give exact instructions in general but rather strategic goals. For example one CBR Solution might say trade the streets that you only have one of each for the ones that you have two of that color already. Then the planner based on the situation on the board needs to decompose this high level task to a low level operations. Like offer \"Mediterranean Avenue\" for \"Reading Railroad\" and offer $50. The exact amounts and actual streets are left to the planer to evaluate. The monopoly CBR database is currently in development on a monopoly clone game called Spaceopoly. The cases are architected based on human player experience and knowledge. There is a plan of making a number of slightly different strategies that differ on the style of playing and then running simulation tests that would determine the particular validity of each database as well as validity of certain segments of the strategy or even particular cases in the database. The actual execution of the strategies will not differ from strategy to strategy since the plan execution is more related to the structure and rules of the game than to the actual playing strategy.",
        "6.3 Details on the Planning Implementation": "For the purpose of planning this implementation uses a modification of the JSHOP2 planner. The Java Simple Hierarchical Ordered Planner 2 is a domain independent HTN planning system [15]. JSHOP2 uses ordered task decomposition in reducing the HTN to list of primitive tasks which form the plans. An ordered task decomposition planner is an HTN planner that plans for tasks in the same order that they will be executed. This reduces the complexity of reasoning by removing a great deal of uncertainty about the world, which makes it easy to incorporate substantial expressive power into the planning algorithm. In addition to the usual HTN methods and operators, the planners can make use of axioms, can do mixed symbolic/numeric conditions, and can do external function calls. In order for the JSHOP2 planer to generate plans it needs tree crucial components: Domain, State and Tasks. The Domain defines all the functionalities that the particular domain offers. These are simple and complex tasks. The complex tasks also called methods create the hierarchy with the fact that they can be evaluated by simple tasks of other complex tasks. This is how a hierarchical structure of tasks is formed. The problem reduction is done by reducing the high level complex tasks to simpler until all the tasks are primitive. The list of primitive tasks forms the plan. The State represents the state of the system. It is a simple database of facts that represent the state of the system. The State is necessary to determine the way the problems or tasks are reduced to their primitive level. The reduction is done by satisfying different prerequisites set in the methods; these prerequisites are defined in the state. The Tasks are high level tasks or methods defined in the Domain. The planner based on the State and the goals selects one or more high level tasks that need to be reduced to plans [Figure 15]. Figure 15: Diagram of a Planner The plans then generate the game moves. The number of moves generated by the plans is just a fraction of the possible moves at that point. This reduces the game tree providing the opportunity to generate smaller and deeper game trees and making more efficient decisions in general.",
        "7. Conclusion": "Even though the results from the CBR database are not complete at this time partial strategies are implemented as cases and recognized during game play by the CBR system. These smaller local strategies coupled with more global higher level strategies that are particularly important at the beginning of the game would form a complete CBR database and represent a knowledge engineered style of playing of the AI player. The AI Planning approach is a proven method by the tictac toe experiment and is suitable for implementing the strategies associated with the CBR cases. This approach in general benefits from both technologies, CBR as well as AI Planning and comprises an elegant solution. Even though AI Planning can be enough as a single technology for some simpler problems like tictactoe the complexity of Monopoly would mean that the Planner would have to incorporate Core Planner Tasks Plan State Interactive and Adaptable Media 301 3rd International Conference on Digital Interactive Media in Entertainment and Arts large and complex domain and a very big state model. The CBR application helps reduce this complexity by focusing the planning on smaller domain of the game. Basically the CBR reduces the overall goal of the play (wining the game) to smaller more concrete goals suitable to the particular state of the game, thus reducing the need for global planning strategies and complex planning domain. Furthermore this symbiosis of technologies gives way for more precise and finely tuned strategies which can be difficult to include into global plan for the whole game. One simple example for the Monopoly game would be this: Sometimes its better to stay in jail because rolling double increases the probability of landing on some field (two, four, six, eight, ten or twelve steps from the jail) that can be of great importance to the rest of the game. These and similar small local strategies can be easily recognized by similar cases in the CBR database. In other words the system is flexible enough so that new strategies can be incorporated easily missing strategies can be also recognized by the distance metrics as well as wrong assumptions in the strategies can be easily recognized. One other important property of the system is that is highly configurable. The game its self can be diversely different depending on the configuration of the board. Even though the platform is restricted to Monopoly type of games, changing the layout and values of the fields effectively brings completely different properties of the game. In addition the CBR database represents the entire experience of the AI Player. It can be filled with rich set of strategies or even configured with different flavors of difficulties of play, this of course coupled with the domain of the planner which can differ from a case to a case as well.",
        "8. Future Work": "Further exploration of this technology would go towards complete implementation of an AI aware agent for monopoly. Initial results from the local cases with more specific strategies show CBR as a capable tool for representing expertise in playing the game. Completing the more general strategies and coupling them with the planning domain will give precise results on the benefits from this architecture. There is also need for exploring the planning of strategies of opponents. This task is to some extent different because we cannot always expect the opponent to select the best move we think. In the Tictactoe example all possible moves of the opponent were taken into consideration, if we used the same planner for the opponent only tie games would result from the game tree. In other words mistakes of the players also need to be considered. The CBR Platform brings other functionalities well worth of exploring as well. The revision stage of the JColibri2 platform is basically capable of fine tuning strategies or even developing new strategies for the games. A well written underlying AI planning model with a capable feedback of the game tree evaluation back to the CBR revision capability can be an interesting concept in automatic experience acquisition for the AI model. There are also many other fields were combined CBR and planning approach can be incorporated into a problem solution. This combination is analogous in a big extent to a human way of reasoning. People in addition to logic of reasoning in situations with lack of information rely to planning strategies and prior experience, exactly the intuition behind CBR AI Planning architecture.",
        "9. ACKNOWLEDGMENTS": "We would like to thank Prof. Sofia Tsekeridou for her involvement in the valuable discussions we had on the topic of CBR. 10."
    },
    "references": [
        "[1] Minimax. Wikipedia. [Online] [Cited: April 23, 2008.] http://en.wikipedia.org/wiki/Minimax. ",
        "[2] Von Neumann, J: Zur theorie der gesellschaftsspiele Math. Annalen. 100 (1928) 295320 ",
        "[3] Automated Planning. Wikipedia. [Online] [Cited: April 23, 2008.] http://en.wikipedia.org/wiki/Automated_planning. ",
        "[4] SanchezRuiz, Antonio, et al. Game AI for a Turnbased Strategy Game with Plan Adaptation and Ontologybased retrieval. ",
        "[5] K. Erol, J. Hendler, and D. Nau (1994). Semantics for hierarchical tasknetwork planning. Technical Report TR94 31, UMIACS. ",
        "[6] Smith, S. J. J. and Dana S. Nau, T. A. Throp. A Planning approach decrarer play in contract bridge. Computational Intelligence. 1996, Vol. 12, 1. ",
        "[7] One Jump Ahead: Challenging Human Supremacy in Checkers. J.Schaeffer. s.l. : SpringerVerlag, 1997. ",
        "[8] IBM. How Deep Blue works. [Online] 1997. [Cited: April 23, 2008.] http://www.research.ibm.com/deepblue/meet/html/d.3.2.html ",
        "[9] Ghallab, Malik, Nau, Dana and Traverso, Paolo. Automated Planning theory and practice. s.l. : Morgan Kaufmann Publishers, May 2004. ISBN 1558608567. ",
        "[10] Case Based Reasoning. Experiences, Lessons and Future. Leake, David. s.l. : AAAI Press. MIT Press., 1997. ",
        "[11] Applying casebased reasoning: techniques for enterprise systems. Watson, I. San Francisco, CA, USA : Morgan Kaufmann Publishers Inc., 1998. ",
        "[12] Plaza, A. Aamodt and E. Casebased reasoning: Foundational issues, methodological. AI Communications. 1994, 7(i). ",
        "[13] Tictactoe. Wikipedia. [Online] [Cited: April 23, 2008.] http://en.wikipedia.org/wiki/Tictactoe. ",
        "[14] D\u00edazAgudo, B. and Gonz\u00e1lezCalero, P. A. An architecture for knowledge intensive CBR systems. Advances in CaseBased Reasoning (EWCBR00). New York : SpringerVerlag, Berlin Heidelberg, 2000. ",
        "[15] Ilghami, Okhtay and Nau, Dana S. A General Approach to Synthesize ProblemSpecific Planners. 2003. 302 DIMEA 2008 3rd International Conference on Digital Interactive Media in Entertainment and Arts"
    ]
}