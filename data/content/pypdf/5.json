[
    "Towards a Quantum Software Modeling Language\nCarlos A. P\u00e9rez-Delgado\u2217\nUniversity of Kent\nCanterbury, Kent, United Kingdom\nc.perez@kent.ac.ukHector G. Perez-Gonzalez\nUniversidad Aut\u00f3noma de San Luis Potos\u00ed\nSan Luis Potos\u00ed, SLP, M\u00e9xico\nhectorgerardo@uaslp.mx\nABSTRACT\nWe setdownthe principles behindamodeling languageforquan-\ntumsoftware.Wepresentaminimalsetofextensionstothewell-\nknownUnifiedModelingLanguage(UML)thatallowsittoeffec-\ntively model quantum software. These extensions are separate and\nindependent of UML as a whole. As such they can be used to ex-\ntend any other software modeling language, or as a basis for a\ncompletely new language. We argue that these extensions are both\nnecessaryandsufficienttomodel,abstractly,anypieceofquantum\nsoftware.Finally,weprovideasmallsetofexamplesthatshowcase\nthe effectiveness of the extension set.\nCCS CONCEPTS\n\u2022Generalandreference \u2192Generalconferenceproceedings ;\nDesign;\u2022Software and its engineering \u2192System descrip-\ntionlanguages ;UnifiedModelingLanguage(UML) ;Software\ndesign engineering ;\u2022Theory of computation \u2192Quantum\ncomputation theory ;Quantum information theory .\nKEYWORDS\nquantum computing, software engineering, UML\nACM Reference Format:\nCarlos A. P\u00e9rez-Delgado and Hector G. Perez-Gonzalez. 2020. Towards a\nQuantum Software Modeling Language. In IEEE/ACM 42nd International\nConferenceonSoftwareEngineeringWorkshops(ICSEW\u201920),May23\u201329,2020,\nSeoul, Republic of Korea. ACM, New York, NY, USA, 3 pages. https://doi.org/\n10.1145/3387940.3392183\n1 INTRODUCTION\nQuantumcomputationrosetoprominenceafterthediscoveryof\nquantum algorithms[ 5,7] that can efficiently perform tasks that\nareintractableclassically.Thesediscoveriespropelledresearchand\ninterest in quantum computation. Today, there exists prototype\nquantum hardware with computational capabilities beyond that of\nanyclassicalmachine[ 1].Furtherapplicationsofquantumtheory\ntocomputationhavealsobeenmadeinseveralareasoftheoryof\ncomputing,suchasmodelsofcomputation[ 6],datastructures[ 8],\nand cryptography[2].\n\u2217Both authors contributed equally to this research.\nPermission to make digital or hard copies of all or part of this work for personal or\nclassroom use is granted without fee provided that copies are not made or distributed\nforprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefullcitation\nonthe firstpage.Copyrights forcomponentsof thisworkowned byothersthan the\nauthor(s)mustbehonored.Abstractingwithcreditispermitted.Tocopyotherwise,or\nrepublish,topostonserversortoredistributetolists,requirespriorspecificpermission\nand/or a fee. Request permissions from permissions@acm.org.\nICSEW\u201920, May 23\u201329, 2020, Seoul, Republic of Korea\n\u00a9 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.\nACM ISBN 978-1-4503-7963-2/20/05...$15.00\nhttps://doi.org/10.1145/3387940.3392183Quantum computation has, until today, been studied almost\nexclusively \u2018in the small.\u2019 A general understanding of quantum\ncomputation,or,quantumprogramming\u2018inthelarge\u2019isyettobe\ndeveloped. Here we aim to set the foundations of a general frame-\nwork for studying, developing, and conveying quantum programs.\nWe aim to do so by developing a universal modeling language\nforquantumsoftware.Ratherthandevelopsuchalanguagefrom\nscratch, we have decided to start from the well-known Unified\nModeling Language (UML)[ 3], and introduce a minimum set of\nextensions that allow it to effectively model quantum software.\nAssumingUMLtobeasharedcommon-languageuponwhich\nwe can build, allows us to convey our original extensions much\nmoresuccinctly.Ourextensionsetcan,however,beappliedwith\nlittle or no modification to any other modeling language.\n2 Q-UML\nBeforediscussingindepththeextensionsweareintroducing,we\nmakeafewfundamentalobservationsonwhichwebasetheguiding\nprinciples for our extension set.\nOurfirstobservationisaboutthenatureofquantumcomputa-\ntion. The central difference between quantum and classical com-\nputationisin howitachievesitsgoals.Quantumcomputershave\naccess to quantum algorithms[ 7], and quantum data-structures[ 8],\nthat are unavailable to classical computers\u2014hence their perfor-\nmance advantage. Algorithms and data-structures are, however,\nimplementationdetails.Algorithms areanessentialdesignchoice\nwhile programming in the small. However, they are more often\nthannotcompletelyignoredinlarge-scalesoftwarearchitectural\ndesign.Forinstance,UMLdiagramsseldomportrayalgorithmsand\ndata-structures beyond a very high-level design perspective.\nIt would seem then that quantum computation introduces noth-\ning to computation that needs to be captured in a software design\ndiagram. This is not the case, and the reason for this is our second\nobservation. Quantum computation changes the very nature of in-\nformation itself.Quantuminformationismuchricherthanclassical\ninformation. It is also much more challenging to store, transmit,\nand receive. If a module (class, object, etc.) needs to store, transmit\norreceivequantuminformation,thenthisisanimportantdesign\nconsideration\u2014whichneedstobeincludedinanyeffectivesoftware\ndesign.\nA third observation here is that the classical vs. quantum nature\nof the information used by a module is an important consideration\nboth when discussing its internal implementation andits interface.\nFurthermore, these two are separate and independent considera-\ntions.\nAclassicalmodule,implementingsomeclassicalbehavior,would\nhavenoneed,orcapability,tocommunicatequantumdata.Aquan-\ntum module may or may not have to; i.e.a module\u2019s quantum\nbehavior may be completely part of its internal implementation\n4422020 IEEE/ACM 42nd International Conference on Software Engineering Workshops (ICSEW)\n",
    "and not appear as part of its interface. For instance, take a module\nimplementing Shor\u2019s algorithm. Shor\u2019s algorithm uses quantum\neffects to efficiently factor a large integer into its prime factors.\nTheimplementationofthismodulemustnecessarilybequantum.\nBoththeinput(thelargeinteger)andtheoutput(theprimefactors),\nconsist of classical information. And hence, the interfaceof such a\nmodule can be strictly classical.\nMore generally, we can conceive of quantum software modules\nthat have all classical inputs and outputs (like the above example),\nall quantum inputs and outputs, or a mix of both. A quantum soft-\nware design must address, for each individual interface element,\nwhether it is classical input/output, or if it is quantum. In short,\nwhether a module communicates classically or via quantum infor-\nmation,andwhetheritsinternalimplementationrequiresquantum\nhardware are important considerations that need to be captured in\na design document.\nThe importance of such labelling should be clear. Quantum data\ncanonlybestoredandtransmittedwithspecialhardwaredesigned\ntodoso.More importantly,fromanabstract,device-independent,\nstrictly software perspective: quantum and classical information\narenotinterchangeable. Classical information is clone-able and\nadmits fanout operations, while quantum information (in general)\ndoes not. On the other hand, quantum information has a much\nlarger state-space.\nFinally,itistruethatquantuminformationisstrictlyasuper-set\nofclassicalinformation\u2014andhenceaquantummodulecancommu-\nnicateanyclassicalinformationitdesiresusingaquantuminterface\nelement. We argue, however, that using a quantum interface ele-\nment and messagingwhen classical would sufficeis bad quantum\nsoftware design, for the reasons stated above.\nInsummary,theguidingprinciplesbehindanyquantumsoftware\nmodeling language must include the following:\n(1)(QuantumClasses): Wheneverasoftwaremodulemakes\nuse of quantum information, either as part of its internal\nstate/implementation,oraspartofitsinterface,thismustbe\nclearly established in a design document.\n(2)(Quantum Elements): Each module interface element ( e.g.\npublicfunctions/methods,publicvariables)andinternalstate\nvariables can be either classical or quantum, and must be\nlabelled accordingly.\n(a)(QuantumVariables): Eachvariableshouldbelabelled\nasclassicalorquantum.Ifthemodelrepresentsdatatypes,\nthe variables should also specify the classical ( e.g.integer,\nstring)orquantum( e.g.qubit,qubitarray,quantumgraph\nstate) data type,\n(b)(QuantumOperations): Foreachoperation,boththein-\nputandoutputshouldbeclearlylabelledaseitherclassical\nor quantum. Whether the operation internally operates\nquantumly should also be labelled.\n(3)(Quantum Supremacy): A module that has at leastone\nquantum element is to be considered a quantum software\nmodule, otherwise it is a classical module. Quantum and\nclassical modules should be clearly labelled as such.\n(4)(QuantumAggregation): Anymodulethatiscomposedof\none or more quantum modules will itself be considered a\nquantum module, and must be labelled as such.(5)(QuantumCommunication): Quantumandclassicalmod-\nules can communicate with each other as long as their inter-\nfacesarecompatible, i.e.thequantummodulehasclassical\ninputs and/or outputs that can interface with the classical\nmodule.\nWe will argue in Sec. 2.3 how these extensions are not only nec-\nessary,butalsosufficientinordertodesignandrepresentquantum\nsoftware.First,inthefollowingtwosectionsweputtheseprinciples\ninto practice as a set of concrete extensions to UML.\n2.1 Class Diagram Extensions\nUMLisaverygraphicallanguage,meanttoconveyalotofmeaning\ninaverysmallamountofspace.Assuch,itmakessensetousea\ngraphicalwaytorepresentquantumsoftwareelements.Wechoseto\ndothisbyuseof boldtexttodenotequantumelements,anddouble\nlinestodenoteaquantumrelationshiporquantumcommunication.\nFigure 1: Q-UML class diagram of Shor\u2019s Algorithm. Quan-\ntum classes and interface elements are presented in bold\ntext, and quantum relationships use double-lines.\nFor attributes, the name will be bold if it is represented using\nquantuminformation.Formethods,weusethefollowingconven-\ntion. If any of the inputs are quantum, these are bold. If the output\nordatatypeofthemethodisquantum,thenthedatatypeshouldalso\nbe bold. For backwards compatibility with regular UML, whenever\ntheinputoroutputdatatypesofamethodareomitted,thesewillbe\nassumedtobeclassicalinnature.Ifaclass/objecthasanyquantum\nattributesormethodsthenititselfisconsideredquantum,andits\nname shall also be bold.\nRelationshipsbetweenclasseswillusedouble-lineswheneverthe\nrelationshipisquantuminnature.Forinheritance,ifthesuperclass\nisquantumthenthesubclass,andtheinheritancerelationship,will\nalso be quantum. (the converse is not necessarily true however).\nIn thecase ofaggregation and composition,if aclass/object being\naggregated/composedisquantum,thentheclass/objecttowhich\nit is aggregated/composed into, as well as that relationship will\n443",
    "alsobe quantum.Associationrelationshipsdonothaveany special\nrules,beyondtheneedofaquantumclass/objecttohaveaclassical\ninterface if it is to associate with classical classes/objects.\nFig.1showcasesaQ-UMLdiagramthatexemplifiestheabove\nrules.\n2.2 Sequence Diagram Extensions\nSequencediagramsinUMLallowustoportraythe dynamic rela-\ntionshipbetweenmodulesinasoftwareprogram.Aswedidbefore\nfor static relationships, we extend the existing language in order to\nallow us to differentiate between classical and quantum messages.\nAs previously discussed, this is essential information. Quantum\ninformationbehavesdifferentlyfromclassicalinformation;itcan\nstore/portraydifferentdata;itadmitsdifferentoperations;and,it\nrequires different hardware to store, send, and receive.\nFigure 2: Q-UML sequence diagram of Shor\u2019s Algorithm.\nQuantum classes are presented in bold text, and quantum\nmessages use double-lines.\nLike before, we make use of boldtext to markup quantum mod-\nules, and double lines to portray quantum messages. Fig. 2 shows a\nQ-UML sequence diagram. Note how even though the relationship\nbetween Shorfactor andShorOrder is quantum, the messaging\nbetween them is not.This illustrates an important point. A module\nis marked as quantum if it uses quantum resources in any form,\neitherdirectlyaspartofitsinternalimplementationoraspartof\nanaggregatedmodule.Ifasub-module(inUMLa composed class\nor object) is quantum, then the encompassing module must also be\nmarked as quantum. In a static ( e.g.class) diagram, the quantum\ncomposition relationships inform us\u2014especially in the case of a\nseemingly classical module that does not in itselfuse quantum\nresources\u2014which composed modules are using quantum resources.\nAlso, note thecommunication between the objects ShorOrder\nandQFT_n. The module QFT_noperates on a quantum state.\nHence, both \u2018set\u2019 messages are quantum. Likewise, the return mes-\nsages \u03c1and\u03c1\u2032arequantumstates.However,therequesttoperform\na quantum Fourier transform (QFT) or a QFT inverse operationcan(andthereforeshould)becommunicatedclassically.Thisdia-\ngram showcases the level of granularity available to us using these\ndiagrams with the proposed extensions.\n2.3 Discussion\nWehaveproposedaminimalseriesofextensionstoexistingsoft-\nware modeling languages. We exemplify our additions in UML,\nbut these extensions are easily applicable to any other modeling\nlanguage, or be used as the basis for a new modeling language.\nWe\u2019vearguedthenecessityofeachoftheextensionsinprevious\nsections.Wecanargueaswell,thattheseextensionsarenotonly\nnecessary, but also sufficient to fully model quantum software.\nTo make this argument, we appeal to the fact that all quantum\ncomputationissimulableusingclassicalcomputationalbeitwith\nanefficiencyloss.Otherthantheiruseofquantuminformationand\nalgorithms,quantumcomputersareindistinctfromclassicalones.\nHence,fromahigh-leveldesign perspective, theonlyinformation\nelement that needs to be considered when developing quantum\nsoftware is when quantum (rather than classical) information is\nbeing used.\nThe one remaininginformation element we have notdiscussed\nis algorithm efficiency. If quantum computation is to be used, it\nwill most likely be due to the efficient algorithms at its disposal.\nThat said, algorithm efficiency is not a solely quantum consider-\nation.UMLitselfdoesnotinherentlyhavelanguageelementsfor\nalgorithm efficiency (beyond user-defined notes). It does, however,\nhave several extensions used and proposed for this purpose(see\ne.g.[4]).Othermodelinglanguagesmayalsohavedefinitealgorithm\nefficiencyelements.Wearguethatitisbesttouseexistinglanguage\nelements when they are available.\nACKNOWLEDGMENTS\nCP-DwouldliketoacknowledgefundingthroughtheEPSRCQuan-\ntumCommunicationsHub(EP/T001011/1).Theauthorswouldalso\nliketothankJoannaI.Ziembickaforusefulcommentsduringthe\npreparation on this manuscript.\nREFERENCES\n[1]FrankArute et.al.2019. Quantumsupremacyusingaprogrammablesupercon-\nducting processor. Nature574, 7779 (2019), 505\u2013510. https://doi.org/10.1038/\ns41586-019-1666-5\n[2]Charles H Bennett and Gilles Brassard. 2014. Quantum cryptography: public key\ndistribution and coin tossing. Theor. Comput. Sci. 560, 12 (2014), 7\u201311.\n[3]GradyBooch,JamesRumbaugh,andIvarJacobson.2005. UnifiedModelingLan-\nguage User Guide, The (2nd Edition) (Addison-Wesley Object Technology Series) .\nAddison-Wesley Professional.\n[4]C. Canevet, S. Gilmore, J. Hillston, M. Prowse, and P. Stevens. 2003. Performance\nmodelling with the Unified Modelling Language and stochastic process algebras.\nIEE Proceedings - Computers and Digital Techniques 150, 2 (March 2003), 107\u2013120.\nhttps://doi.org/10.1049/ip-cdt:20030084\n[5]Lov K. Grover. 1996. A Fast Quantum Mechanical Algorithm for Database\nSearch. In Proceedings of the Twenty-eighth Annual ACM Symposium on The-\nory of Computing (STOC \u201996) . ACM, New York, NY, USA, 212\u2013219. https:\n//doi.org/10.1145/237814.237866\n[6]CarlosA.P\u00e9rez-DelgadoandDonnyCheung.2007. Localunitaryquantumcellular\nautomata. Phys. Rev. A 76 (Sep 2007), 032320. Issue 3. https://doi.org/10.1103/\nPhysRevA.76.032320\n[7]PeterWShor.1994. Algorithmsforquantumcomputation:Discretelogarithms\nandfactoring.In Proceedings35thannualsymposiumonfoundationsofcomputer\nscience. Ieee, 124\u2013134.\n[8]LimingZhao,CarlosA.P\u00e9rez-Delgado,andJosephF.Fitzsimons.2016. Fastgraph\noperationsinquantumcomputation. Phys.Rev.A 93(Mar2016),032314. Issue3.\nhttps://doi.org/10.1103/PhysRevA.93.032314\n444"
]