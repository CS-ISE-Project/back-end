[
    "How to Teach Software Modeling\nTetsuo Tamai\nGraduate School of Arts and Sciences\nThe University of Tokyo\n3-8-1 Komaba, Meguro-ku\nTokyo 153-8902, Japan\ntamai@acm.org\nABSTRACT\nTo enhance motivation of students to study software engineering,\nsome way of \ufb01nding balance between the scienti\ufb01c aspect and the\npractical aspect of software engineering is required. In this paper,\nwe claim that teaching multiple software modeling techniques from\na uni\ufb01ed viewpoint is a good way of obtaining the balance and\nattracting the students\u2019 interest as well.\nCategories and Subject Descriptors\nK.3.2 [ Computers and Education ]: Computer and Information\nScience Education\u2014 computer science education ; D.2.1 [ Software\nEngineering ]: Requirements/Speci\ufb01cation\u2014 modeling\nGeneral Terms\nDesign\nKeywords\nsoftware modeling, software engineering education, UML\n1. INTRODUCTION\nSoftware engineering education at universities faces a common\nproblem; that is regular students do not usually have experience of\ndeveloping software for practical use and thus are not motivated for\nsoftware engineering aiming at high quality software production\nby a project team or a persistent organization. Software projectsconducted by students simulating real scale software development\nmay help enhance students\u2019 motivation, although it requires a lot of\nefforts to prepare such projects and manage them.\nAnother way of solving this problem is to teach those who al-\nready have real experience in industry. In our case, there are cur-rently \ufb01ve Ph. D. students under the author\u2019s supervision who are\nworking at companies as well as doing research in our lab. As\na by-product, interactions between the part-time students and the\nother regular students stimulate each other, particularly enlighten-\ning the regular students to practical software issues. However, too\nmuch emphasis on practicality may bring negligence to science and\nCopyright is held by the author/owner.\nICSE\u201905, May 15\u201321, 2005, St. Louis, Missouri, USA.\nACM 1-58113-963-2/05/0005.technology and may generate anti-intellectualism. A good balance\nbetween the scienti\ufb01c aspect and the practical aspect of software\nengineering should always be pursued.\nIn our view, teaching various software modeling techniques is a\ngood way to achieve balanced software engineering education. It\nis needless to say that model is a key concept and modeling is an\nessential skill in software engineering. There are a variety of mod-\neling techniques; some are intuitive and quite accessible to novices,\nwhile some are highly sophisticated and attract theory oriented stu-\ndents and researchers.\nIn this paper, we would like to show that it is effective to teach\nmultiple modeling techniques from a uni\ufb01ed viewpoint. It is based\non our experience of teaching software engineering courses at sev-\neral universities in Japan. Recently, the author published a textbook\non software engineering, speci\ufb01cally focused on software model-ing (unfortunately, it is written in Japanese)[1]. The book covers\nthe whole area of software engineering, including design, testing\nand evolution but the modeling part has a role of attracting inter-\nests of intelligent students, who may not have much experience in\ndeveloping real scale software systems. It also gives a consistent\nviewpoint penetrating through various techniques employed in dif-\nferent stages of software engineering.\n2. MODELING TECHNIQUES\nIn software engineering, models are used for various purposes,\ne.g. life cycle model, process model, project model, product model,quality model, domain model, requirements model, design model,\nobject model, data model, etc. In the following, we basically focus\non requirements and design models but most of the discussions will\nhold for other kinds of models.\nTeaching modeling is almost equal to teaching abstraction. Mod-\nels are constructed through capturing the crucial properties and\nstructure of the target, abstracting away irrelevant details. Thus,\nlearning how to model is a good training for mastering abstraction.\n2.1 Graph Representation of Models\nMany software models are represented with diagrams. Wide ac-\nceptance of UML symbolizes the trend that diagrams are often pre-\nferred to textual languages. Among many types of diagrams, graphstructured diagrams are by far the most widely used. The reasons\nmay be as follows.\n1. A most fundamental way for human mind to understand the\nworld is by regarding it as consisting of a set of conceptual\nunits and a set of relations between them. Conceptual units\ncan be naturally illustrated with boxes or circles or whateverclosed \ufb01gures and relations can be illustrated with lines or ar-\nrows connecting such \ufb01gures, corresponding to vertices and\nedges of graphs, respectively.\n609 \n",
    "2. It is easy to draw graph structured diagrams by hand or with\ndrawing tools.\n3. Concepts and algorithms of the graph theory are available\nand often useful in analyzing models represented by graphs.\nA typical example is reasoning on transitive relations by trac-\ning along paths of graphs. Also, the concept of subgraph is\nhighly useful in decomposing higher-level models or cluster-ing lower-level models.\nAccordingly, a number of models share the same structure of\ngraphs. Table 1 shows graph structures of some typical models.\nTable 1: Graph structures of typical models\nmodel\n vertex\n edge\nData \ufb02ow\n process\n data \ufb02ow\nER\n entity\n relationship\nState transition\n state\n transition\nJSD\n process\n data stream connection\nstate vector connection\nActivity\n activity\n control \ufb02ow\nPetri net\n place, transition\n \ufb01re and token \ufb02ow\n2.2 Commonality and Difference between\nModels\nIt is pedagogical to let students notice the common structure\nshared by a number of models. However, the apparent resemblance\noften causes confusion. Such confusion can be observed not only\nin software modeling graphs but in many diagrams found in daily\nnewspapers, magazines, reports, proposals and other documents. It\nis often the case that one vertex denotes a type of things and an-other denotes quite a different type on the same diagram or one\ntype of edges co-exist with edges with different meaning. Thus,\nit is important to make students consciously aware the differences\nbetween different models. We often experience that when we let\nstudents draw data \ufb02ow diagrams who appear to have understood\nthe data \ufb02ow model perfectly, the diagrams turn out to be some-\nthing like control \ufb02ow graphs.\nTo show the difference, it is instructive to categorize models rep-\nresented by graphs. Basically, there are two categories.\n1. Static models:\nAn edge connecting vertex A and vertex B represents a rela-\ntion between A and B. When the edge is undirected, it means\n\u201cA and B are in some relation\u201d and when directed, it means\n\u201cA has a relation with B\u201d. Typical examples include entity\nrelationship model, class diagram and semantic network.\n2. Dynamic models:\nAn edge from vertex A to B denotes a move from A to B.\nThe edge in this case is always directed. There are two sub-categories:\n(a) The case where a view of control moves from A to B.\nExamples are control \ufb02ow model and state transition\nmodel.\n(b) The case where data or objects \ufb02ow from A to B. Exam-\nples are data \ufb02ow model, work \ufb02ow model, and trans-\nportation \ufb02ow model.Static models and dynamic models may not be easily confused\nbut confusion between different dynamic models are often observed,\ne.g. data \ufb02ow and control \ufb02ow or state transition and activity tran-\nsition. Since graphs are intuitively understandable, their semantics\nare apt to be understood ambiguously or misunderstood.\n3. UML\nUML diagrams can also be viewed in terms of graph structures.\nTable 2 shows graph structures of \ufb01ve UML diagrams.\nTable 2: Graph structures of UML diagrams\ndiagram\n vertex\n edge\nclass diagram\n class\n generalization,\ncomposition,\nassociation\nstate machine\n state\n transition\nactivity diagram\n activity\n control \ufb02ow\ncollaboration diagram\n object\n message \ufb02ow\nsequence diagram\n message\n message \ufb02ow\nanchor point\nIt is usually not desirable to teach UML per se. UML is a col-\nlection of miscellaneous diagrams and its speci\ufb01cation is continu-ously changing. For the pedagogical purpose, UML had better be\nregarded as a catalogue of analysis and design know-how collected\naround diagrammatic representations. Diagrams should be selected\naccording to the policy of how to teach modeling methods.\nEach UML diagram contains overly rich constructs, which some-\ntimes blur the essential property of the model. For example, the\nactivity diagram is essentially a control \ufb02ow diagram but it also in-\ncludes a notation for data \ufb02ow description. From the stance of em-\nphasizing differences between various models, it is not appropriate\nto include such ad hoc constructs. By the same token, the collab-oration diagram (, renamed to \u201ccommunication diagram\u201d in UML\n2) is explained to have the equivalent semantics as the sequence\ndiagram. But if that is the case, signi\ufb01cance of the collaboration\ndiagram is considerably limited. The author prefers to regard it as\nshowing collaboration relations between objects, integrating a set\nof different sequence diagrams.\n4. CONCLUSION\nSoftware modeling is important by itself but teaching modeling\nin the software engineering course has at least two additional mean-\nings. One is to give a bird\u2019s-eye view to the whole software engi-\nneering through the standpoint of modeling technology. The other\nis to attract interest of good students who may not have much expe-\nrience in developing a real-scale software but possess intelligenceand will to attack complexity of modern software construction.\n5. REFERENCES\n[1] T. Tamai. Foundations of Software Engineering . Iwanami\nShoten, Tokyo, Japan, 2004. in Japanese.\n610 "
]