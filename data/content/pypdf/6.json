[
    "A Prototype Implementation of an Orthographic Software\nModeling Environment\nColin Atkinson\nUniversity of Mannheim,\nGermany\natkinson@informatik.uni-\nmannheim.deDietmar Stoll\nUniversity of Mannheim,\nGermany\nstoll@informatik.uni-\nmannheim.de\nChristian Tunjic\nUniversity of Mannheim,\nGermany\ntunjic@informatik.uni-\nmannheim.deJacques Robin\nUniversidade Federal de\nPernambuco, Recife, Brasil\njr@cin.ufpe.br\nABSTRACT\nOrthographic Software Modeling (OSM) is a view-centric\nsoftware engineering approach that aims to leverage the or-\nthographic projection metaphor used in the visualization of\nphysical objects to visualize software systems. Although the\ngeneral concept of OSM does not prescribe speci\ufb01c sets of\nviews, a concrete OSM environment has to be speci\ufb01c about\nthe particular views to be used in a particular project. At\nthe University of Mannheim we are developing a prototype\nOSM environment, nAOMi, that supports the views de\ufb01ned\nby the KobrA 2.0 method, a version of KobrA adapted for\nOSM. In this paper we provide an overview of the KobrA 2.0\nmetamodel underpinning nAOMi and give a small example\nof its use to model a software system.\nCategories and Subject Descriptors\nD.1.7 [ Programming Techniques ]: Visual Programming;\nD.2.2 [ Design Tools and Techniques ]: Computer-aided\nsoftware engineering (CASE); D.2.6 [ Software Engineer-\ning]: Programming Environments\u2014 Graphical environments\nKeywords\nOrthographic Software Modeling, View-based Modeling\n1. INTRODUCTION\nOrthographic Software Modeling (OSM) is based on three\nfundamental hypotheses \u2014 (a) that it is feasible to inte-\ngrate the many di\ufb00erent kinds of artifacts used in contempo-\nrary software engineering methods within a single coherent\nmethodology in which they are treated as views, (b) that it\nPermission to make digital or hard copies of all or part of this work for\npersonal or classroom use is granted without fee provided that copies are\nnot made or distributed for pro\ufb01t or commercial advantage and that copies\nbear this notice and the full citation on the \ufb01rst page. To copy otherwise, to\nrepublish, to post on servers or to redistribute to lists, requires prior speci\ufb01c\npermission and/or a fee.\nVAO \u201913, July 2, 2013, Montpellier, France\nCopyright 2013 ACM 978-1-4503-2041-2 ...$15.00.is feasible to create an e\ufb03cient and scalable way of support-\ning these views by generating them dynamically, on-the-\ufb02y,\nfrom a Single Underlying Model (SUM) using model-based\ntransformations and (c) that it is feasible to provide an in-\ntuitive metaphor for navigating around these many views\nby adapting the orthographic projection technique under-\npinning the CAD tools used in other engineering disciplines.\nFigure 1: Orthographic Projection.\nAs shown in Figure 1, the main advantages of using the\nidea of orthographic projection to de\ufb01ne the views used\nto visualize and described a system are that they (a) can\nbe organized according to a simple and easy-to-understand\nmetaphor and (b) collectively represent all the properties of\na system with minimal overlap and redundancy. In practice\nthis translates into a set of \u201cdimensions\u201d, each containing\nwell de\ufb01ned choices (or so called \u201cdimension elements\u201d) that\ncan be used to select individuals views.\nAs shown in Figure 2, the main advantage of making the\nartifacts used to describe a software system views of a SUM\nis that the number of pairwise coherence relationships that\nhave to be maintained is reduced and new views can be in-\ntroduced by simply de\ufb01ning their relationship to the SUM.\nMoreover, the importance of this advantage grows quickly\nas the size of the system and the complexity of the deployed\ndevelopment methodology increase. Another important ad-\nvantage is that the dominance of one particular kind of view\nover the development process (e.g. code) at the expense of\nother kinds of views (e.g. graphical models) is reduced so\nthat any appropriate type of views can be used to enrich\nthe underlying description of the system, depending on the\nneeds and skills of the stakeholder involved. This makes it\npossible to subsume all view types under the same, overarch-\n",
    "SUM\nSUM / View Centric Environment Artifact / Tools Centric EnvironmentFigure 2: Consistency Dependencies in Artifact-oriented versus View-oriented Environments.\ning development process and methodology (e.g. agile-driven,\nfocusing on small development cycles, or model-driven de-\nvelopment, based on transformations between abstraction\nlevels). Although the details of how the views are created\nfrom the SUM and how the SUM is updated from the views\nare not central to the approach, a natural implementation\nis to use the visualization and transformation technologies\no\ufb00ered by model driven software engineering (MDSE).\nTo explore the validity of these hypotheses at the Uni-\nversity of Mannheim we have been developing a prototype\nOSM modeling environment based on an enhanced version\nof the KobrA method for model-driven, component-oriented\ndevelopment, KobrA 2.0 [1]. This was chosen as a basis for\nthe prototype, known as the Open, Adaptable, Orthographic\nModeling Environment (nAOMi) [13] because its views were\ndesigned with the precise goals of being (a) genuine pro-\njections of a subject containing carefully selected subsets\nof information about that subject, (b) minimalistic in the\nsense that they should overlap to the smallest extent possible\nand contain the minimum necessary models elements, and\n(c) selectable via a set of independent \u201cdimensions\u201d which\nre\ufb02ect di\ufb00erent fundamental concerns of development (i.e.\nabstraction levels, composition or variants). In other words,\nKobrA already provided one of the \u201cmost orthogonal\u201d sets\nof views for visualizing software systems of any contempo-\nrary method. More details about the actual views and di-\nmensions de\ufb01ned in KobrA are presented in the following\nsections. More information on OSM can be found in [2] and\n[3].\nnAOMi is implemented as an Eclipse plugin using the\nEclipse Modeling Framework (EMF) as the underlying mod-\neling platform and UML 2.0 tools [4] to generate and edit\nviews. The KobrA 2.0 metamodel on which the current\nversion of nAOMi is based is a specialization of the UML\nmetamodel composed of three separate packages \u2014 one for\nthe SUM, one for the views and one for the transformations\n(Figure 3). The UML was chosen as the base language be-\ncause of its maturity and widespread acceptance, making the\nenvironment usable to the largest possible body of develop-\ners. UML elements not needed in KobrA 2.0 are excluded\nusing OCL constraints while new elements or properties are\nKobrA2\nTransformation SUM ViewsFigure 3: KobrA 2.0 Top Level Packages.\nintroduced by specializing existing elements.\nThe unique contribution of this paper is to elaborate on\nthe structure of the KobrA 2.0 metamodel and how it is used\nto drive nAOMi. The three following sections each focus on\none of the three main components of the metamodel \u2014 the\nSUM, the views and the transformations . This is followed\nby a brief overview of the OSM navigation paradigm in Sec-\ntion 5 before a small example of the approach is presented in\nSection 6. Section 7 then concludes the paper with related\nand future work.\n2. SUM PACKAGE\nFigure 4 depicts the internal structure of the SUM pack-\nage which is based on the UML metamodel. There are three\nmain subpackages, two containing the structural and behav-\nioral constructs respectively, and one containing the con-\nstraints that ensure that the metaclasses are used according\nto the KobrA conventions and rules.\nThe Classes subpackage of the Structure package contains\nsome of the most fundamental elements of the KobrA meta-\nmodel, such as Class and ComponentClass . The internal\nstructure of this package is illustrated in Figure 5. Com-\nponentClass represents objects with complex and reusable\nbehaviors, while Class captures simple \u201cdata type\u201d objects\nthat have only very simple or non-reusable behaviors. The\nmodeler has to decide whether it is necessary to model a\nspeci\ufb01c part of the system as a ComponentClass and include\nstate charts and activity diagrams, or whether it is su\ufb03cient\nto use a Class (which is limited to using OCL constraints).\nComponentClass inherits (indirectly via Class ) from Com-\nmunications so it also has the isActive attribute. This makes",
    "KobrA2::SUM::Constraint::Behavioral KobrA2::SUM::Constraint::StructuralKobrA2::SUM::Constraint\nKobrA2::SUM::Constraint::CommonKobrA2::SUM::Behavior::ProtocolStateMachines\nKobrA2::SUM::Behavior::CommonKobrA2::SUM::Behavior::ActivitiesKobrA2::SUM::Behavior::ActionsKobrA2::SUM::Behavior\nKobrA2::SUM::Structure::Classes\nKobrA2::SUM::Structure::TypesKobrA2::SUM::Structure::Instances\nKobrA2::SUM::Structure::ElementsKobrA2::SUM::Structure\nKobrA2::SUM::Constraint::OclExpressions<<merge>>\n<<merge>>\n<<merge>> <<merge>><<merge>><<merge>>\n<<merge>><<merge>> <<merge>>\n<<merge>><<merge>>\n<<merge>>Figure 4: KobrA 2.0 SUM Package.\nit possible to model whether its instances are active or pas-\nsive. Active objects, which can be used to model threads and\nprocesses ([8] p. 438), start to execute their behavior as soon\nas they are created and perform operations spontaneously.\nAComponentClass may exhibit complex behavior. In Ko-\nbrA, this behavior may be speci\ufb01ed in the form of UML\nState Diagrams (de\ufb01ning acceptable operation invocation\nsequences), and in the form of Activities (de\ufb01ning algorithms\nof operations). UML Interaction elements (in sequence dia-\ngrams) can be derived from the activity elements and thus\nare not included in the SUM. As KobrA aims to facilitate\nautomatic checking of allowed sequences of operation calls,\nProtocol State Machines are supported instead of general\nstate machines. Since the latter include a large variety of\nelements not needed for specifying acceptable operation se-quences or automatic checking, OCL constraints are used to\nprohibit the use of unwanted features.\ncontext ComponentClass\n-- only allow Activity elements or\nProtocolStateMachines\ninv: ownedBehavior -> forAll ( oclIsKindOf ( Actitivity ) or\noclIsKindOf ( ProtocolStateMachine ))\nFor example, since KobrA has no concept of roles for com-\nponents, the use of rolealso needs to be prohibited. The part\nassociation refers to owned properties of components whose\nattribute isComposite is true. As KobrA uses associations\nlike nests and creates for components, part,required and\nprovided are not needed. Connectors (i.e. delegation and\nassembly ) are not used in KobrA either so ownedConnector\nis excluded.",
    "ClassKobrA2::SUM::Structure::Classes\nGeneralizationSet\nAssociationClass\nComponentClassProperty\nUsageAssociation\nOperationPackageable\nElement\nParameterAcquires Creates NestsUML::Component::PackagingComponents::ComponentUML::CommonBehaviors::Communications::Class\n+ownedOperation\n*+class\n0..1+supplier\n1..*\n{subsets supplierDependency}+supplierUsage*\n+client\n1..*\n{subsets clientDependency}+clientUsage*+ownedAttribute\n*+class\n0..1\n+powertype\n0..1+powertypeExtent\n*\n+packagedElement*{subsets component}+componentClass 0..1\n+/superClassFigure 5: KobrA 2.0 Classes Package.\ncontext ComponentClass\ninv: role -> union ( part ) ->union ( ownedConnector )\n->union ( collaborationUse ) -> union ( representation )\n->union ( realization ) ->union ( required )\n->union ( provided ) -> isEmpty ()\n3. VIEWS PACKAGE\nThe structure of the Views package is illustrated in Figure\n6. Again, since most of the views de\ufb01ned in KobrA 2.0 are\nbased on UML diagrams, the view metamodels have similar\nelements to the SUM metamodel. The big di\ufb00erence to the\nSUM is that there are no restrictions on the use of the view\nmetamodel elements. For instance, views for a particular\npurpose such as supporting model checkers can be supported\nby adding elements unrelated to the UML.\nThe substructure of the Views package re\ufb02ects the types\nand organization of the KobrA views according to the view\n\u201cdimensions\u201d supported in nAOMi (cf. example in Section\n6). At the top level, the Views package is thus decomposed\ninto the Speci\ufb01cation and Realization options of the encap-\nsulation dimension. These, in turn are both decomposed\ninto the Structural, Behavioral and Operational options of\nthe Projection dimension. Finally, with the exception of\nthe behavioral option, these are also all subdivided into the\nService andType options of the granularity dimension. Thisdimension, with its two options, is an addition to the original\nversion of KobrA.\nThe Service view shows the direct, publicly visible rela-\ntionships of the subject ComponentClass to other Compo-\nnentClasses , while the Type view shows the publicly visi-\nble relationships of the subject to simple Classes . As with\nthe SUM, constraints have been de\ufb01ned to control what can\ngo into each view and when they are well formed. For ev-\nery view, a constraint enumerates all allowed elements (not\nshown in this paper).\nIn the following, some of the other constraints for the\nService view are elaborated. Since this view is a black-box\nview, the internals of ComponentClasses (nestedClassi\ufb01er )\nare not shown.\ncontext ComponentClass\n-- no nested classifiers , no protocol\ninv: nestedClassifier -> union ( protocol ) -> isEmpty ()\nClasses are only allowed if they are generalizations of Com-\nponentClasses , (or any of its superclasses, since a Compo-\nnentClass may inherit from a class as shown in the con-\nstraints with context Class. The following invariants ensure\nthat only publicly visible attributes and operations are in\nthis view, for both classes and ComponentClasses (which\ninherit from Class ).",
    "Class\nService TypeInstance\nService TypeStructuralSpecification\nOperational\nService TypeProtocolBehavioral\nKobrA2::Views::Derived\nComponentClassDependencies OperationDependenciesInstance\nService TypeClass\nService TypeStructuralRealization\nOperational\nService TypeBehavioral\nAlgorithmViews\nConcreteSyntax Subject\n<<import>> <<merge>><<merge>> <<import>>\n<<merge>> <<import>>Figure 6: KobrA 2.0 Views package nesting.\ncontext Class\n-- only allow classes that are direct or indirect\ngeneralizations of ComponentClasses in this view\ndef: ccGeneralization : generalization . specific ->\nexists ( oclIsKindOf ( ComponentClass ))\ninv: generalization . specific -> select ( oclIsTypeOf (\nClass )) -> exists (s|s. ccGeneralization )\nor ccGeneralization\n-- only public attributes in this view\ninv: ownedAttribute -> forAll ( visibility =# public )\n-- only public Operations are allowed in the\nspecification\ninv: ownedOperation -> forAll ( visibility =# public )\nOnly operation signatures are shown in this view, so pre-,\npost- and bodyconditions, as well as activities are omitted,which is re\ufb02ected in the last constraint.\ncontext Operation\n-- only the signature of the Operation is shown , not\nits behavior ( role name \" method \" refers to the\nActivities of the operation ), or dependencies\ninv: method -> union ( precondition ) ->union ( body ) ->union (\npostcondition ) -> isEmpty ()\n4. TRANSFORMATIONS PACKAGE\nThe package AllViews provides the foundation for speci-\nfying the transformations between the SUM and the views\nin both directions. Part of the package\u2019s contents are shown\nin Figure 7. The Abstraction concept (which is in fact a",
    "KobrA2::Transformation::Common::AllViews\nAbstraction\nTransformationExpression\nViewElement SumElementView\nKobrA2::SUM::Structure::Elements::Element KobrA2::Views::ConcreteSyntax::ElementKobrA2::SUM::Constraint::Behavioral::Exp\nressionInOclKobrA2::Views::Subject::View\n{subsets mapping}0..1 0..1\n{subsets clientDependency}+abstraction\n1\n{subsets client}\n+ve 11..* 1\n{subsets supplier}\n+se\n1{subsets supplierDependency}+abstraction 1..*Figure 7: Transformation abstractions.\ndependency reused from the UML but with additional con-\nstraints) plays the key role in relating elements from the\nSUM to elements of a view. Abstraction is actually mapped\ntoExpressionInOcl . When appearing in transformations,\nthe equals sign links elements in the SUM to the respective\nelements in the view, and vice versa. For instance, equal-\nity of the general meta-association of a Generalization in\na transformation invariant means that, when following gen-\neral, there must be an element in the SUM and in the view\nfor which similar transformation expressions are speci\ufb01ed.\nIn the case of KobrA 2.0, which has many projections that\njust select a subset of elements using one-to-one abstrac-\ntions, this allows concise declarative TransformationExpres-\nsions . Together with the view constraints, a CASE tool can\nbe implemented which uses a transformation language of the\nimplementor\u2019s choice, for instance the Atlas Transformation\nLanguage (ATL) [11] or QVT [9]. The role names seandve\nare short for SumElement and ViewElement, respectively.\nThese roles subset the client and supplier roles from the\nUML.\nSUM elements are translated into UML elements with\nstereotypes, so that the views are easy to manage for de-\nvelopers familiar with the UML. The bidirectional mappings\nbetween stereotyped view elements and non-stereotyped SUM\nelements are expressed in the constraints of the Association-\nAbstraction, a subclass of the Abstraction from the AllViews\npackage. This is also an example of a transformation which\nis reused in other views.\ncontext AssociationAbstraction\ninv: ve. memberEnd = se. memberEnd\ninv: ve. ownedEnd = se. ownedEnd\nivn: ve. navigableOwnedEnd = se. navigableOwnedEnd\ninv: se. oclIsKindOf ( Acquires ) implies ve.\nhasStereotype (\u2019 acquires \u2019)\ninv: ve. hasStereotype (\u2019 acquires \u2019) implies se.\noclIsKindOf ( Aquires )\ninv: se. oclIsKindOf ( Nests ) implies ve. hasStereotype (\u2019\nnests \u2019)inv: ve. hasStereotype (\u2019nests \u2019) implies se. oclIsKindOf\n( Nests )\ninv: se. oclIsKindOf ( Creates ) implies ve. hasStereotype\n(\u2019 creates \u2019)\ninv: ve. hasStereotype (\u2019 creates \u2019) implies se.\noclIsKindOf ( Creates )\nFigure 8 shows the main elements involved in the trans-\nformation of the black box structural view for Component-\nClasses . The \ufb01rst transformation constraint is on the view\nand declares the starting point for the transformation. It\nstates that the subject ComponentClass and its generaliza-\ntions (using a SUM utility function, superClosure ) are in the\nview.\nThe following transformation rules illustrate how to create\nthe output (i.e. view) elements from the input (i.e. SUM) el-\nements, such as the publicly visible attributes and operations\nof the ComponentClass and the acquired ComponentClasses .\nThe \ufb01rst constraint for ComponentClassAbstraction states\nthat references to potential general classes (and Component-\nClasses ) ofComponentClasses are mirrored in the view. In\naddition, ComponentClasses will be shown with the corre-\nsponding stereotypes. The ComponentClass owns various\ntypes of associations, so in this view only the acquires asso-\nciations are selected (whose transformation rules are cov-\nered in the common transformation packages).For classes\nand ComponentClasses , only publicly visible attributes and\noperations appear in the view. Class invariants are also\ncopied. Classes that may appear in this view (e.g. as gener-\nalizations of ComponentClasses ) may have a powertype (role\nname powertypeExtent ) which will be displayed.\nThe last transformation statement copies the class refer-\nences of operations. As with all views, the transformation\nrules, the common transformation statements (which also\ncover operations) and the view constraints serve as a speci-\n\ufb01cation for the implementation of a view. Individual CASE\ntools can use di\ufb00erent implementation techniques as long as\nthey conform to the semantics of these rules and constraints.",
    "KobrA2::Transformation::Specification::Structural::Class::Service\nComponentClassAbstraction\nKobrA2::Transformation::Common::Feature::OperationAbstractionKobrA2::Transformation::Common::AllViews::Abstraction\nKobrA2::SUM::Structure::Classes::ComponentClass\nKobrA2::SUM::Structure::Classes::OperationKobrA2::SUM::Structure::Classes::Class\nOperationAbstractionClassAbstraction+se\n1 1..*\n+se\n1 1..*\n+se\n1 1..*Figure 8: Transformation to the Speci\ufb01cation Structural Service View.\ncontext KobrA2 :: Views :: Subject ::\nSpecificationStructuralClassService\ninv: ownedMember -> select ( oclIsKindOf ( Class )) =\nsubject . superClosure -> union ( subject . acquires .\nsuperClosure )\ncontext ComponentClassAbstraction\ninv: ve. superClass = se. superClass\ninv: ve. hasStereotype (\u2019 ComponentClass \u2019)\ninv: se. isSubject implies (ve. hasStereotype (\u2019 subject\n\u2019) and ve. ownedMember -> select ( oclIsKindOf (\nAssociation )) = se. ownedMember -> select (\noclIsKindOf ( Acquires )))\ncontext ClassAbstraction\ninv: ve. ownedAttribute = se. ownedAttribute -> select (\nvisibility =# public )\ninv: ve. ownedOperation = se. ownedOperation -> select (\nvisibility =# public )\ninv: ve.\u2018inv \u2019 = se.\u2018inv \u2019\n-- copy powertypeExtent that is only allowed for\nclass\ninv: ve. powertypeExtent = se. powertypeExtent\ncontext OperationAbstraction\ninv: ve. class = se. class\nFor the black box type view, only publicly visible at-\ntributes and operations of classes (as opposed to Compo-\nnentClasses ) used by the subject can be seen. This is spec-\ni\ufb01ed in the \ufb01rst rule which de\ufb01nes owned members of the\nview and thus serves as the starting point of the transfor-\nmation. cbbTypes is a utility function de\ufb01ned in the SUM\nwhich computes the black box types by selecting the types\nof the subject\u2019s public attributes and parameter types of its\npublic operations.\nClass invariants and potential powertypes and connections\nto the classes in this view are shown as well. There may\nalso be Enumerations , for which the EnumerationLiterals\nare displayed.\nThe transformation rules for this view are almost the same\nas the realization transformation constraints from the pack-\nageTransformation::Realization::Structural::Class::Type . The\ndi\ufb00erences are the select(visibility=#public) statements for\noperations and attributes.\ncontext KobrA2 :: Views :: Subject ::\nSpecificationStructuralClassType\ninv: ownedMember -> select ( oclIsKindOf ( Class ) or\noclIsKindOf (\u2018 Enumeration \u2019) or oclIsKindOf (\nAssociation )) = subject -> union ( subject . cbbTypes )context ComponentClassAbstraction\ninv: se. isSubject implies ve. hasStereotype (\u2019 subject \u2019)\ncontext ClassAbstraction\ninv: not se. oclIsKindOf ( ComponentClass ) implies (\nve. ownedAttribute = se. ownedAttribute -> select (\nvisibility =# public )\nve. ownedOperation = se. ownedOperation -> select (\nvisibility =# public ))\ninv: ve. powertypeExtent = se. powertypeExtent\ninv: ve. superClass = se. superClass\ninv: \u2018ve.inv \u2019 = \u2018se.inv \u2019\ncontext ComponentClassAbstraction\ninv: se. isSubject implies ve. hasStereotype (\u2019 subject \u2019)\ncontext EnumerationAbstraction\ninv: ve. ownedLiteral = se. ownedLiteral\ncontext EnumerationLiteralAbstraction\ninv: ve. specification = se. specification .\nstringInSignature\n5. NA VIGATION\nMost of today\u2019s tools use some combination of trees to\norganize the content of models as well as the views used to\nvisualize a software system or component. In an any envi-\nronment incorporating a number of di\ufb00erent tools there is\ninvariably a large number of di\ufb00erent trees storing a het-\nerogeneous mix of artifacts including model elements (e.g.\nclasses, instances, associations), diagrams (e.g. class dia-\ngrams, state diagrams) and other artifact types (source code,\nXML \ufb01les, con\ufb01guration \ufb01les ). To work with all the views in\na traditional development environment, therefore, engineers\ntypically have to learn about the organization structures of\nall the incorporated tools.\nIn contrast to conventional paradigms for organizing and\nnavigating the many views used to visualize a system, OSM\nemploys the metaphor of a multi-dimensional cube. More\nspeci\ufb01cally, as illustrated in Figure 9, OSM regards dimen-\nsion of the underlying methodology as representing a di\ufb00er-\nent dimension of the cube, and each independently variable\naspect of that dimension is a selectable dimension element.\nSelecting a view thus simply corresponds to selecting a single\ncell within the cube. In general, three types of dimensions\nare supported: static dimensions in which the number of",
    "Figure 9: Dimension-based navigation.\nselectable elements (i.e. coordinates) is \ufb01xed, dynamic di-\nmensions in which the number of elements is dynamic (i.e.\nderived from the SUM), and mixed dimensions which have\nboth static and dynamic elements.\nTo support the OSM dimension based navigation metaphor\nfor KobrA, we de\ufb01ned the seven dimensions indicated on the\nleft hand side of Figure 10 which is a sceenshot of nAOMI.\nThe Abstraction dimension (not expanded here), which has\nthree static dimension elements, PIM (platform independent\nmodel), PSM (platform speci\ufb01c model) and Code, captures\nthe model-driven development concern of KobrA. The ver-\nsion dimension captures the state of the modeled system at\nspeci\ufb01c points in time. The Component dimension, which\nhas dynamic dimension elements de\ufb01ned by instances of the\nclass ComponentClass in the SUM, captures the component-\nbased development concern of KobrA.\nThe Encapsulation dimension, which has two \ufb01xed ele-\nments, supports the distinction between Speci\ufb01cation (black\nbox) and Realization (white box) views of components, while\nthe Projection dimension with the \ufb01xed elements Structural,\nOperational and Behavioral covers the di\ufb00erent information\ntypes. The Granularity dimension provides a \ufb01ner grained\ndistinction between views describing the types used by com-\nponents (Type granularity) and views describing the required\nand provided interfaces (Service granularity). The Opera-\ntion dimension allows a selection of individual operations.\nIn the ideal case, when all views are truly orthogonal, the\nchoices that can be made in each dimensions are completely\nindependent. However, this is very di\ufb03cult to achieve in\nsoftware engineering. The approach still works if the views\nare not completely orthogonal, but dependencies then occur\nbetween di\ufb00erent choices in di\ufb00erent dimensions, so that the\ndecisions made in one dimensions may a\ufb00ect choices possi-\nble in another dimension. This is best handled by giving\ndimensions a precedence ranking determined by the order\nin which they appear (the top being the highest). When an\nelement in a dimension is selected, the tool automatically\nmakes default selections for dimensions of lower precedence\n(i.e. dimensions lower down) and disables selections that\nwould navigate to cells (i.e. views) which are not (yet) de-\n\ufb01ned by the method at hand.\n6. SHOPPING CART EXAMPLE\nTo show how a software system can be speci\ufb01ed using\nnAOMi, this section presents a case study based on a shop-\nping cart system. A ShoppingCart component collects and\nFigure 10: Speci\ufb01cation Structural View.\nmanages the products selected by users and supports pay-\nment via a credit card. Figure 10 illustrates a structural\nview of the component.\nIn the dimension navigator on the left hand side, PIM\nwas chosen for the \u201cAbstraction Level\u201d (not expanded in the\nscreenshot). The second dimension is the state of the soft-\nware system at a certain point in time. The picture shows\nthat the latest available version was chosen. As with every\nchoice in a dimension, it may in\ufb02uence the options in lower\nranked dimensions. The component under consideration is\nthe ShoppingCart, for which a black box view is selected\nin the next dimension. After the user selects the structural\nprojection option and the service level granularity, the tool\nautomatically chooses the option for all operations in the\nlast dimension, as there is no editor registered for the other\noptions.\nThe component under development is presented with the\nstereotype subject and its relationship to other components\nand classes is shown in the view, which corresponds to a cell\nof the multi-dimensional navigation cube, and is generated\non-the-\ufb02y from the SUM when it is selected. The classes\nProduct and CreditCard can be used as data types in the\noperations of the component.\nFigure 11 illustrates the operational view in which an\noperation can be formalized using pre- and postconditions.\nThe precondition corresponds to the assumes clause in and\nthe postcondition corresponds to the result clause. As in the\nUML, the precondition of an operation must be true when\nthe operation is invoked and the postcondition must be true\nwhen the operation is \ufb01nished. The operation addProduct\nin Figure 11 must be in state CollectingProducts orEmpty\nwhen invoked. This is also visible in the behavioral view,",
    "Figure 11: addProduct() Operation Speci\ufb01cation.\nsince there are only two transitions with the operation ad-\ndProduct . Both leads to the state CollectingProducts which\nis also a postcondition of the operation. The second post-\ncondition is that the cost attribute of the component must\nbe increased by the price of the added product. The pre- and\npostcondition can be expressed using the OCL. The proper-\nties of the component, states and operation parameters can\nbe used to formalise the constraints like as in this example.\nFigure 12 shows the publicly visible behaviour of the Shop-\npingCart component with states and transitions. The condi-\ntional transitions map to operations of the component. Like\nevery view, this view is also synchronized with the SUM so\nthat it is guaranteed that its operations, states and proper-\nties are consistent with those in the structural view.\nFigure 12: Speci\ufb01cation Behavioral Model.\nAlthough the operational view seems to be similar to the\nbehavioral view because of the overlapping information withinthem, there are signi\ufb01cant di\ufb00erences. The focus of the op-\nerational view is on a precise formal de\ufb01nition of an opera-\ntion of a component. The operations can be enriched by pre-\nand postconditions which can be de\ufb01ned using complex OCL\nstatements, that formalize the complete behavior of an op-\neration. The additional information in the OCL statements\ncan be used for code generation and documentation.\n7. CONCLUSION\nAt the beginning of the paper we identi\ufb01ed three funda-\nmental hypothesis upon which the notion of OSM is based\n\u2014 (a) that it is feasible to integrate the many di\ufb00erent kinds\nof artifacts used in contemporary software engineering meth-\nods within a single coherent methodology in which they are\ntreated as views, (b) that it is feasible to create an e\ufb03-\ncient and scalable way of supporting these views by gener-\nating them dynamically, on-the-\ufb02y, from a Single Underly-\ning Model (SUM) using model-based transformations and\n(c) that it is feasible to provide an intuitive metaphor for\nnavigating around these many views by adapting the ortho-\ngraphic projection technique underpinning the CAD tools\nused in other engineering disciplines.\nThe prototype tool, nAOMi, described in this paper rep-\nresents the \ufb01rst step towards demonstrating the validity of\nthese hypotheses and showing that OSM is a viable approach\nto software engineering. Of the three hypotheses, (a) and (c)\nare most convincingly demonstrated by the prototype, since\nit shows that it is indeed possible to support all the views\nof the KobrA method within a single navigation metaphor.\nThe prototype tool does not demonstrate the validity of hy-\npothesis (b) to the same extent as the others due to its\nsmall size. Although it demonstrates the feasibility of gen-\nerating views from the SUM and vice-versa, the question of\nwhether such an approach scales up to large environments\nis still open.\nAlthough nOAMi is the only tool developed with the spe-\nci\ufb01c aim of supporting KobrA-based OSM, several other\ntools and methods have similar properties or aims. For\nexample, Glinz et al. [10] describe a tool with a \ufb01sheye\nzooming algorithm which lets the user view a model with\nvarying amounts of detail depending on the context. It has\nto be investigated whether it is possible to combine the \ufb01sh-\neye zooming concept with the dimension-based navigation\nparadigm. While the KobrA 2.0 implementation of nAOMi\nheavily uses UML diagrams for developers, Glinz et al. use",
    "custom diagram types, e.g. for structural and behavioral\nviews.\nAn approach which also emphasizes the description of for-\nmal consistency rules ( correspondences ) between views is\nRM-ODP [5][6]. However, this approach does not explic-\nitly mention the notion of a SUM and thus implies that\nconsistency rules should be de\ufb01ned in a pairwise fashion be-\ntween individual pairs of views. ArchiMate [7], which com-\nplements TOGAF [12], is an enterprise architecture mod-\neling language which o\ufb00ers two orthogonal \u201ddimensions\u201d for\nmodeling, ( business ,architecture, and technology ) layers and\n(informational ,behavioral and structural ) aspects and also\nsuggests two more dimensions, purpose andabstraction level .\nHowever, as many of these views span multiple choices of a\nsingle \u201cdimension\u201d, the intuitive dimension-based navigation\nmetaphor of OSM can not be easily applied. There are also\nmore general approaches for view-based modeling but they\nare less speci\ufb01c in terms of consistency rules between views\nand provide little guidance on how to manage and navigate\nviews, for example the Zachman Framework [14].\nRegarding the practical use of OSM environments in the\nfuture, the biggest challenge is developing appropriate SUM\nmetamodels which can accommodate all the types of views\nand services that software engineers are accustomed to to-\nday. For this \ufb01rst prototypical SUM-based environment sup-\nporting the OSM approach we had a method at our disposal\n(KobrA) that already de\ufb01ned a full set of orthogonal UML-\nbased views. This allowed us to model the required SUM\nand view metamodels by simply adapting the UML meta-\nmodels, removing and adding model elements as needed.\nIn doing so we were able to manually ensure that the meta-\nmodels ful\ufb01lled the two core requirements of SUM-based en-\nvironments \u2014 (1) being minimalistic and (2) redundancy\nfree. If SUM-based software engineering environments are\nto take o\ufb00, and to be introduced into existing, heteroge-\nneous environments, more sophisticated ways of integrating\nexisting metamodels into a single uni\ufb01ed metamodel will be\nrequired.\n8. REFERENCES\n[1] C. Atkinson, J. Bayer, C. Bunse, E. Kamsties,\nO. Laitenberger, R. Laqua, D. Muthig, B. Paech,\nJ. W \u00a8ust, and J. Zettel. Component-Based Product Line\nEngineering with UML . Addison Wesley, Reading,\nMassachusetts, USA, 1st edition, November 2001.\n[2] C. Atkinson, D. Stoll, and P. Bostan. Orthographic\nSoftware Modeling: A Practical Approach to\nView-Based Development. In Evaluation of Novel\nApproaches to Software Engineering , volume 69 ofCommunications in Computer and Information\nScience , pages 206\u2013219. Springer Berlin Heidelberg,\n2010.\n[3] C. Atkinson, D. Stoll, and C. Tunjic. Orthographic\nService Modeling. In Proceedings of 15th IEEE EDOC\nConference Workshops (EDOCW), Helsinki, Finland ,\n2011.\n[4] Eclipse Foundation. UML2Tools.\nhttp://wiki.eclipse.org/MDT-UML2Tools , 2013.\n[5] ISO/IEC and ITU-T. The Reference Model of Open\nDistributed Processing. RM-ODP, ITU-T Rec.\nX.901-X.904 / ISO/IEC 10746.\nhttp://standards.iso.org/\nittf/PubliclyAvailableStandards/index.html ,\n1998.\n[6] J. I. J. Jose Raul Romero and A. Vallecillo. Realizing\nCorrespondences in MultiViewpoint Speci\ufb01cations. In\nProceedings of the Thirteenth IEEE International\nEDOC Conference, 1 - 4 September 2009, Auckland,\nNew Zealand , September 2009.\n[7] M. Lankhorst. Enterprise Architecture at Work .\nSpringer Berlin Heidelberg, 2009.\n[8] Object Management Group (OMG). OMG Uni\ufb01ed\nModeling Language (OMG UML), Superstructure,\nV2.1.2.\nhttp://www.omg.org/cgi-bin/doc?formal/07-11-02 ,\nNovember 2007.\n[9] Object Management Group (OMG). Meta Object\nFacility (MOF) 2.0 Query/View/Transformation, v1.0.\nhttp://www.omg.org/spec/QVT/1.0/PDF/ , April 2008.\n[10] C. Seybold, M. Glinz, S. Meier, and N. Merlo-Schett.\nAn e\ufb00ective layout adaptation technique for a\ngraphical modeling tool. In Proceedings of the 2003\nInternational Conference on Software Engineering,\nPortland , 2003.\n[11] The Atlas Transformation Language (ATL). O\ufb03cial\nWebsite. http://www.eclipse.org/atl/ , 2013.\n[12] The Open Group. TOGAF Version 9 - The Open\nGroup Architecture Framework.\nhttp://www.opengroup.org/architecture/\ntogaf9-doc/arch/index.html , Feb 2009.\n[13] University of Mannheim - Software Engineering\nGroup. nAOMi - opeN, Adaptable, Orthographic\nModeling EnvIronment.\nhttp://eclipselabs.org/p/naomi .\n[14] J. A. Zachman. The Zachman Framework: A Primer\nfor Enterprise Engineering and Manufacturing.\nhttp://www.zachmaninternational.com , 2009."
]