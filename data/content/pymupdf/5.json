[
    "Towards a Quantum Software Modeling Language\nCarlos A. P\u00e9rez-Delgado\u2217\nUniversity of Kent\nCanterbury, Kent, United Kingdom\nc.perez@kent.ac.uk\nHector G. Perez-Gonzalez\nUniversidad Aut\u00f3noma de San Luis Potos\u00ed\nSan Luis Potos\u00ed, SLP, M\u00e9xico\nhectorgerardo@uaslp.mx\nABSTRACT\nWe set down the principles behind a modeling language for quan-\ntum software. We present a minimal set of extensions to the well-\nknown Unified Modeling Language (UML) that allows it to effec-\ntively model quantum software. These extensions are separate and\nindependent of UML as a whole. As such they can be used to ex-\ntend any other software modeling language, or as a basis for a\ncompletely new language. We argue that these extensions are both\nnecessary and sufficient to model, abstractly, any piece of quantum\nsoftware. Finally, we provide a small set of examples that showcase\nthe effectiveness of the extension set.\nCCS CONCEPTS\n\u2022 General and reference \u2192 General conference proceedings;\nDesign; \u2022 Software and its engineering \u2192 System descrip-\ntion languages; Unified Modeling Language (UML); Software\ndesign engineering; \u2022 Theory of computation \u2192 Quantum\ncomputation theory; Quantum information theory.\nKEYWORDS\nquantum computing, software engineering, UML\nACM Reference Format:\nCarlos A. P\u00e9rez-Delgado and Hector G. Perez-Gonzalez. 2020. Towards a\nQuantum Software Modeling Language. In IEEE/ACM 42nd International\nConference on Software Engineering Workshops (ICSEW\u201920), May 23\u201329, 2020,\nSeoul, Republic of Korea. ACM, New York, NY, USA, 3 pages. https://doi.org/\n10.1145/3387940.3392183\n1\nINTRODUCTION\nQuantum computation rose to prominence after the discovery of\nquantum algorithms[5, 7] that can efficiently perform tasks that\nare intractable classically. These discoveries propelled research and\ninterest in quantum computation. Today, there exists prototype\nquantum hardware with computational capabilities beyond that of\nany classical machine[1]. Further applications of quantum theory\nto computation have also been made in several areas of theory of\ncomputing, such as models of computation[6], data structures[8],\nand cryptography[2].\n\u2217Both authors contributed equally to this research.\nPermission to make digital or hard copies of all or part of this work for personal or\nclassroom use is granted without fee provided that copies are not made or distributed\nfor profit or commercial advantage and that copies bear this notice and the full citation\non the first page. Copyrights for components of this work owned by others than the\nauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or\nrepublish, to post on servers or to redistribute to lists, requires prior specific permission\nand/or a fee. Request permissions from permissions@acm.org.\nICSEW\u201920, May 23\u201329, 2020, Seoul, Republic of Korea\n\u00a9 2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.\nACM ISBN 978-1-4503-7963-2/20/05...$15.00\nhttps://doi.org/10.1145/3387940.3392183\nQuantum computation has, until today, been studied almost\nexclusively \u2018in the small.\u2019 A general understanding of quantum\ncomputation, or, quantum programming \u2018in the large\u2019 is yet to be\ndeveloped. Here we aim to set the foundations of a general frame-\nwork for studying, developing, and conveying quantum programs.\nWe aim to do so by developing a universal modeling language\nfor quantum software. Rather than develop such a language from\nscratch, we have decided to start from the well-known Unified\nModeling Language (UML)[3], and introduce a minimum set of\nextensions that allow it to effectively model quantum software.\nAssuming UML to be a shared common-language upon which\nwe can build, allows us to convey our original extensions much\nmore succinctly. Our extension set can, however, be applied with\nlittle or no modification to any other modeling language.\n2\nQ-UML\nBefore discussing in depth the extensions we are introducing, we\nmake a few fundamental observations on which we base the guiding\nprinciples for our extension set.\nOur first observation is about the nature of quantum computa-\ntion. The central difference between quantum and classical com-\nputation is in how it achieves its goals. Quantum computers have\naccess to quantum algorithms[7], and quantum data-structures[8],\nthat are unavailable to classical computers\u2014hence their perfor-\nmance advantage. Algorithms and data-structures are, however,\nimplementation details. Algorithms are an essential design choice\nwhile programming in the small. However, they are more often\nthan not completely ignored in large-scale software architectural\ndesign. For instance, UML diagrams seldom portray algorithms and\ndata-structures beyond a very high-level design perspective.\nIt would seem then that quantum computation introduces noth-\ning to computation that needs to be captured in a software design\ndiagram. This is not the case, and the reason for this is our second\nobservation. Quantum computation changes the very nature of in-\nformation itself. Quantum information is much richer than classical\ninformation. It is also much more challenging to store, transmit,\nand receive. If a module (class, object, etc.) needs to store, transmit\nor receive quantum information, then this is an important design\nconsideration\u2014which needs to be included in any effective software\ndesign.\nA third observation here is that the classical vs. quantum nature\nof the information used by a module is an important consideration\nboth when discussing its internal implementation and its interface.\nFurthermore, these two are separate and independent considera-\ntions.\nA classical module, implementing some classical behavior, would\nhave no need, or capability, to communicate quantum data. A quan-\ntum module may or may not have to; i.e. a module\u2019s quantum\nbehavior may be completely part of its internal implementation\n442\n2020 IEEE/ACM 42nd International Conference on Software Engineering Workshops (ICSEW)\n",
    "and not appear as part of its interface. For instance, take a module\nimplementing Shor\u2019s algorithm. Shor\u2019s algorithm uses quantum\neffects to efficiently factor a large integer into its prime factors.\nThe implementation of this module must necessarily be quantum.\nBoth the input (the large integer) and the output (the prime factors),\nconsist of classical information. And hence, the interface of such a\nmodule can be strictly classical.\nMore generally, we can conceive of quantum software modules\nthat have all classical inputs and outputs (like the above example),\nall quantum inputs and outputs, or a mix of both. A quantum soft-\nware design must address, for each individual interface element,\nwhether it is classical input/output, or if it is quantum. In short,\nwhether a module communicates classically or via quantum infor-\nmation, and whether its internal implementation requires quantum\nhardware are important considerations that need to be captured in\na design document.\nThe importance of such labelling should be clear. Quantum data\ncan only be stored and transmitted with special hardware designed\nto do so. More importantly, from an abstract, device-independent,\nstrictly software perspective: quantum and classical information\nare not interchangeable. Classical information is clone-able and\nadmits fanout operations, while quantum information (in general)\ndoes not. On the other hand, quantum information has a much\nlarger state-space.\nFinally, it is true that quantum information is strictly a super-set\nof classical information\u2014and hence a quantum module can commu-\nnicate any classical information it desires using a quantum interface\nelement. We argue, however, that using a quantum interface ele-\nment and messaging when classical would suffice is bad quantum\nsoftware design, for the reasons stated above.\nIn summary, the guiding principles behind any quantum software\nmodeling language must include the following:\n(1) (Quantum Classes): Whenever a software module makes\nuse of quantum information, either as part of its internal\nstate/implementation, or as part of its interface, this must be\nclearly established in a design document.\n(2) (Quantum Elements): Each module interface element (e.g.\npublic functions/methods, public variables) and internal state\nvariables can be either classical or quantum, and must be\nlabelled accordingly.\n(a) (Quantum Variables): Each variable should be labelled\nas classical or quantum. If the model represents data types,\nthe variables should also specify the classical (e.g. integer,\nstring) or quantum (e.g. qubit, qubit array, quantum graph\nstate) data type,\n(b) (Quantum Operations): For each operation, both the in-\nput and output should be clearly labelled as either classical\nor quantum. Whether the operation internally operates\nquantumly should also be labelled.\n(3) (Quantum Supremacy): A module that has at least one\nquantum element is to be considered a quantum software\nmodule, otherwise it is a classical module. Quantum and\nclassical modules should be clearly labelled as such.\n(4) (Quantum Aggregation): Any module that is composed of\none or more quantum modules will itself be considered a\nquantum module, and must be labelled as such.\n(5) (Quantum Communication): Quantum and classical mod-\nules can communicate with each other as long as their inter-\nfaces are compatible, i.e. the quantum module has classical\ninputs and/or outputs that can interface with the classical\nmodule.\nWe will argue in Sec. 2.3 how these extensions are not only nec-\nessary, but also sufficient in order to design and represent quantum\nsoftware. First, in the following two sections we put these principles\ninto practice as a set of concrete extensions to UML.\n2.1\nClass Diagram Extensions\nUML is a very graphical language, meant to convey a lot of meaning\nin a very small amount of space. As such, it makes sense to use a\ngraphical way to represent quantum software elements. We chose to\ndo this by use of bold text to denote quantum elements, and double\nlines to denote a quantum relationship or quantum communication.\nFigure 1: Q-UML class diagram of Shor\u2019s Algorithm. Quan-\ntum classes and interface elements are presented in bold\ntext, and quantum relationships use double-lines.\nFor attributes, the name will be bold if it is represented using\nquantum information. For methods, we use the following conven-\ntion. If any of the inputs are quantum, these are bold. If the output\nor datatype of the method is quantum, then the datatype should also\nbe bold. For backwards compatibility with regular UML, whenever\nthe input or output datatypes of a method are omitted, these will be\nassumed to be classical in nature. If a class/object has any quantum\nattributes or methods then it itself is considered quantum, and its\nname shall also be bold.\nRelationships between classes will use double-lines whenever the\nrelationship is quantum in nature. For inheritance, if the superclass\nis quantum then the subclass, and the inheritance relationship, will\nalso be quantum. (the converse is not necessarily true however).\nIn the case of aggregation and composition, if a class/object being\naggregated/composed is quantum, then the class/object to which\nit is aggregated/composed into, as well as that relationship will\n443\n",
    "also be quantum. Association relationships do not have any special\nrules, beyond the need of a quantum class/object to have a classical\ninterface if it is to associate with classical classes/objects.\nFig. 1 showcases a Q-UML diagram that exemplifies the above\nrules.\n2.2\nSequence Diagram Extensions\nSequence diagrams in UML allow us to portray the dynamic rela-\ntionship between modules in a software program. As we did before\nfor static relationships, we extend the existing language in order to\nallow us to differentiate between classical and quantum messages.\nAs previously discussed, this is essential information. Quantum\ninformation behaves differently from classical information; it can\nstore/portray different data; it admits different operations; and, it\nrequires different hardware to store, send, and receive.\nFigure 2: Q-UML sequence diagram of Shor\u2019s Algorithm.\nQuantum classes are presented in bold text, and quantum\nmessages use double-lines.\nLike before, we make use of bold text to markup quantum mod-\nules, and double lines to portray quantum messages. Fig. 2 shows a\nQ-UML sequence diagram. Note how even though the relationship\nbetween Shorfactor and ShorOrder is quantum, the messaging\nbetween them is not. This illustrates an important point. A module\nis marked as quantum if it uses quantum resources in any form,\neither directly as part of its internal implementation or as part of\nan aggregated module. If a sub-module (in UML a composed class\nor object) is quantum, then the encompassing module must also be\nmarked as quantum. In a static (e.g. class) diagram, the quantum\ncomposition relationships inform us\u2014especially in the case of a\nseemingly classical module that does not in itself use quantum\nresources\u2014which composed modules are using quantum resources.\nAlso, note the communication between the objects ShorOrder\nand QFT_n. The module QFT_n operates on a quantum state.\nHence, both \u2018set\u2019 messages are quantum. Likewise, the return mes-\nsages \u03c1 and \u03c1\u2032 are quantum states. However, the request to perform\na quantum Fourier transform (QFT) or a QFT inverse operation\ncan (and therefore should) be communicated classically. This dia-\ngram showcases the level of granularity available to us using these\ndiagrams with the proposed extensions.\n2.3\nDiscussion\nWe have proposed a minimal series of extensions to existing soft-\nware modeling languages. We exemplify our additions in UML,\nbut these extensions are easily applicable to any other modeling\nlanguage, or be used as the basis for a new modeling language.\nWe\u2019ve argued the necessity of each of the extensions in previous\nsections. We can argue as well, that these extensions are not only\nnecessary, but also sufficient to fully model quantum software.\nTo make this argument, we appeal to the fact that all quantum\ncomputation is simulable using classical computation albeit with\nan efficiency loss. Other than their use of quantum information and\nalgorithms, quantum computers are indistinct from classical ones.\nHence, from a high-level design perspective, the only information\nelement that needs to be considered when developing quantum\nsoftware is when quantum (rather than classical) information is\nbeing used.\nThe one remaining information element we have not discussed\nis algorithm efficiency. If quantum computation is to be used, it\nwill most likely be due to the efficient algorithms at its disposal.\nThat said, algorithm efficiency is not a solely quantum consider-\nation. UML itself does not inherently have language elements for\nalgorithm efficiency (beyond user-defined notes). It does, however,\nhave several extensions used and proposed for this purpose(see\ne.g.[4]). Other modeling languages may also have definite algorithm\nefficiency elements. We argue that it is best to use existing language\nelements when they are available.\nACKNOWLEDGMENTS\nCP-D would like to acknowledge funding through the EPSRC Quan-\ntum Communications Hub (EP/T001011/1). The authors would also\nlike to thank Joanna I. Ziembicka for useful comments during the\npreparation on this manuscript.\nREFERENCES\n[1] Frank Arute et. al. 2019. Quantum supremacy using a programmable supercon-\nducting processor. Nature 574, 7779 (2019), 505\u2013510.\nhttps://doi.org/10.1038/\ns41586-019-1666-5\n[2] Charles H Bennett and Gilles Brassard. 2014. Quantum cryptography: public key\ndistribution and coin tossing. Theor. Comput. Sci. 560, 12 (2014), 7\u201311.\n[3] Grady Booch, James Rumbaugh, and Ivar Jacobson. 2005. Unified Modeling Lan-\nguage User Guide, The (2nd Edition) (Addison-Wesley Object Technology Series).\nAddison-Wesley Professional.\n[4] C. Canevet, S. Gilmore, J. Hillston, M. Prowse, and P. Stevens. 2003. Performance\nmodelling with the Unified Modelling Language and stochastic process algebras.\nIEE Proceedings - Computers and Digital Techniques 150, 2 (March 2003), 107\u2013120.\nhttps://doi.org/10.1049/ip-cdt:20030084\n[5] Lov K. Grover. 1996.\nA Fast Quantum Mechanical Algorithm for Database\nSearch. In Proceedings of the Twenty-eighth Annual ACM Symposium on The-\nory of Computing (STOC \u201996). ACM, New York, NY, USA, 212\u2013219.\nhttps:\n//doi.org/10.1145/237814.237866\n[6] Carlos A. P\u00e9rez-Delgado and Donny Cheung. 2007. Local unitary quantum cellular\nautomata. Phys. Rev. A 76 (Sep 2007), 032320. Issue 3. https://doi.org/10.1103/\nPhysRevA.76.032320\n[7] Peter W Shor. 1994. Algorithms for quantum computation: Discrete logarithms\nand factoring. In Proceedings 35th annual symposium on foundations of computer\nscience. Ieee, 124\u2013134.\n[8] Liming Zhao, Carlos A. P\u00e9rez-Delgado, and Joseph F. Fitzsimons. 2016. Fast graph\noperations in quantum computation. Phys. Rev. A 93 (Mar 2016), 032314. Issue 3.\nhttps://doi.org/10.1103/PhysRevA.93.032314\n444\n"
]