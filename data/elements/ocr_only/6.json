[
    {
        "element_id": "8c789571-c2a0-426a-ad0a-693f6d771215",
        "metadata": {},
        "text": "\u00ae",
        "type": "UncategorizedText"
    },
    {
        "element_id": "c0d4ff04-5b25-4b7e-affb-10cc90ce93fc",
        "metadata": {},
        "text": "Check for \u2018updates",
        "type": "Title"
    },
    {
        "element_id": "e1b6f325-6996-4114-9ae8-4d18051ca861",
        "metadata": {},
        "text": "A Prototype Implementation of an Orthographic Software Modeling Environment",
        "type": "Title"
    },
    {
        "element_id": "d1d7f7e3-931a-4c4a-a6dc-40092854a49d",
        "metadata": {},
        "text": "Colin Atkinson University of Mannheim, Germany",
        "type": "Title"
    },
    {
        "element_id": "fc8eee4d-f9b8-46db-8d2e-8641a89c0004",
        "metadata": {},
        "text": "atkinson@informatik.uni-",
        "type": "EmailAddress"
    },
    {
        "element_id": "43f9b3b9-10d2-4b8c-97c1-b3ff5614ee03",
        "metadata": {},
        "text": "mannheim.de",
        "type": "Title"
    },
    {
        "element_id": "475b4188-98bc-4c20-94aa-6287e8fb4e02",
        "metadata": {},
        "text": "Christian Tunjic University of Mannheim, Germany tunjic@informatik.uni- mannheim.de",
        "type": "Title"
    },
    {
        "element_id": "2336bf01-7b92-4fa3-b7bb-60ce57cf76fe",
        "metadata": {},
        "text": "ABSTRACT",
        "type": "Title"
    },
    {
        "element_id": "5cad58c2-bc73-4b5e-8370-2a6fc4a7d02b",
        "metadata": {},
        "text": "Orthographic Software Modeling (OSM) is a view-centric software engineering approach that aims to leverage the or- thographic projection metaphor used in the visualization of physical objects to visualize software systems. Although the general concept of OSM does not prescribe specific sets of views, a concrete OSM environment has to be specific about the particular views to be used in a particular project. At the University of Mannheim we are developing a prototype OSM environment, nAOMi, that supports the views defined by the KobrA 2.0 method, a version of KobrA adapted for OSM. In this paper we provide an overview of the KobrA 2.0 metamodel underpinning nAOMi and give a small example of its use to model a software system.",
        "type": "NarrativeText"
    },
    {
        "element_id": "333c38e8-c52e-4536-99e7-981b540a0d2d",
        "metadata": {},
        "text": "Categories and Subject Descriptors",
        "type": "Title"
    },
    {
        "element_id": "87e49ec6-5a74-48d9-abcb-c5c7f3add9de",
        "metadata": {},
        "text": "D.1.7 [Programming Techniques]: Visual Programming; D.2.2 [Design Tools and Techniques]: Computer-aided software engineering (CASE); D.2.6 [Software Engineer- ing]: Programming Environments\u2014Graphical environments",
        "type": "UncategorizedText"
    },
    {
        "element_id": "783c8c6f-0ee3-4802-94e8-936169178b46",
        "metadata": {},
        "text": "Keywords Orthographic Software Modeling, View-based Modeling",
        "type": "Title"
    },
    {
        "element_id": "dbaeb3fc-05ec-4946-8229-7d4c2a5d3cb1",
        "metadata": {},
        "text": "1. INTRODUCTION",
        "type": "ListItem"
    },
    {
        "element_id": "b52c31e8-382e-437a-b397-6eeca83d1351",
        "metadata": {},
        "text": "Orthographic Software Modeling (OSM) is based on three fundamental hypotheses \u2014 (a) that it is feasible to inte- grate the many different kinds of artifacts used in contempo- rary software engineering methods within a single coherent methodology in which they are treated as views, (b) that it",
        "type": "NarrativeText"
    },
    {
        "element_id": "2c596da0-eecf-474e-b32f-9305bb09b3aa",
        "metadata": {},
        "text": "Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee.",
        "type": "NarrativeText"
    },
    {
        "element_id": "c6c64de8-1727-43b2-9d18-c1696debe158",
        "metadata": {},
        "text": "VAO \u201913, July 2, 2013, Montpellier, France",
        "type": "Title"
    },
    {
        "element_id": "8129ac13-6972-4442-8008-e00040ffb4ba",
        "metadata": {},
        "text": "Copyright 2013 ACM 978-1-4503-2041-2 ...$15.00.",
        "type": "UncategorizedText"
    },
    {
        "element_id": "1f3ddce4-0a77-48b6-a4f1-4023f53fb096",
        "metadata": {},
        "text": "Dietmar Stoll University of Mannheim, Germany stoll@informatik.uni- mannheim.de",
        "type": "Title"
    },
    {
        "element_id": "6f4ab441-6c88-4c94-b0b0-b2c0a22a6b60",
        "metadata": {},
        "text": "Jacques Robin Universidade Federal de Pernambuco, Recife, Brasil jr@cin.ufpe.br",
        "type": "Title"
    },
    {
        "element_id": "b208d306-e309-466f-acd5-223061fcb53b",
        "metadata": {},
        "text": "is feasible to create an efficient and scalable way of support- ing these views by generating them dynamically, on-the-fly, rom a Single Underlying Model (SUM) using model-based transformations and (c) that it is feasible to provide an in- tuitive metaphor for navigating around these many views y adapting the orthographic projection technique under- pinning the CAD tools used in other engineering disciplines.",
        "type": "NarrativeText"
    },
    {
        "element_id": "9489e80d-d520-4733-b64e-c1b3c111bb68",
        "metadata": {},
        "text": "Figure 1: Orthographic Projection.",
        "type": "Title"
    },
    {
        "element_id": "f713666a-1fd5-4e97-8135-26dac0f8e4e9",
        "metadata": {},
        "text": "As shown in Figure 1, the main advantages of using the idea of orthographic projection to define the views used to visualize and described a system are that they (a) can be organized according to a simple and easy-to-understand metaphor and (b) collectively represent all the properties of a system with minimal overlap and redundancy. In practice this translates into a set of \u201cdimensions\u201d, each containing well defined choices (or so called \u201cdimension elements\u201d) that can be used to select individuals views.",
        "type": "NarrativeText"
    },
    {
        "element_id": "bafd1be7-d942-4549-823f-ff0767302967",
        "metadata": {},
        "text": "As shown in Figure 2, the main advantage of making the artifacts used to describe a software system views of a SUM is that the number of pairwise coherence relationships that have to be maintained is reduced and new views can be in- troduced by simply defining their relationship to the SUM. Moreover, the importance of this advantage grows quickly as the size of the system and the complexity of the deployed development methodology increase. Another important ad- vantage is that the dominance of one particular kind of view over the development process (e.g. code) at the expense of other kinds of views (e.g. graphical models) is reduced so that any appropriate type of views can be used to enrich the underlying description of the system, depending on the needs and skills of the stakeholder involved. This makes it possible to subsume all view types under the same, overarch-",
        "type": "NarrativeText"
    },
    {
        "element_id": "fa2f929d-2f91-4e65-bc92-d2fb41d7dde4",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "c7456203-8b03-4ee8-87ae-aa9c6ada26a1",
        "metadata": {},
        "text": "Artifact / Tools Centric Environment",
        "type": "Title"
    },
    {
        "element_id": "72dbc5eb-2d18-40a2-9cea-c748ee2e9e6b",
        "metadata": {},
        "text": "SUM / View Centric Environment",
        "type": "Title"
    },
    {
        "element_id": "9db70e61-aba7-41f0-93c9-b7195be1c573",
        "metadata": {},
        "text": "Figure 2: Consistency Dependencies in Artifact-oriented versus View-oriented Environments.",
        "type": "Title"
    },
    {
        "element_id": "4337c46f-ded9-4ba0-a707-899bff4a691c",
        "metadata": {},
        "text": "ing development process and methodology (e.g. agile-driven, focusing on small development cycles, or model-driven de- velopment, based on transformations between abstraction levels). Although the details of how the views are created from the SUM and how the SUM is updated from the views are not central to the approach, a natural implementation is to use the visualization and transformation technologies offered by model driven software engineering (MDSE).",
        "type": "NarrativeText"
    },
    {
        "element_id": "549eb54c-456c-4f9c-849e-af3d12ddbf1e",
        "metadata": {},
        "text": "To explore the validity of these hypotheses at the Uni- versity of Mannheim we have been developing a prototype OSM modeling environment based on an enhanced version of the KobrA method for model-driven, component-oriented development, KobrA 2.0 [1]. This was chosen as a basis for the prototype, known as the Open, Adaptable, Orthographic Modeling Environment (nAOMi) [13] because its views were designed with the precise goals of being (a) genuine pro- jections of a subject containing carefully selected subsets of information about that subject, (b) minimalistic in the sense that they should overlap to the smallest extent possible and contain the minimum necessary models elements, and (c) selectable via a set of independent \u201cdimensions\u201d which reflect different fundamental concerns of development (i.e. abstraction levels, composition or variants). In other words, KobrA already provided one of the \u201cmost orthogonal\u201d sets of views for visualizing software systems of any contempo- rary method. More details about the actual views and di- mensions defined in KobrA are presented in the following sections. More information on OSM can be found in [2] and",
        "type": "NarrativeText"
    },
    {
        "element_id": "72ba7e77-7967-488e-9972-bf2b88ced973",
        "metadata": {},
        "text": "nAOMi is implemented as an Eclipse plugin using the Eclipse Modeling Framework (EMF) as the underlying mod- eling platform and UML 2.0 tools [4] to generate and edit views. The KobrA 2.0 metamodel on which the current version of nAOMi is based is a specialization of the UML metamodel composed of three separate packages \u2014 one for the SUM, one for the views and one for the transformations (Figure 3). The UML was chosen as the base language be- cause of its maturity and widespread acceptance, making the environment usable to the largest possible body of develop- ers. UML elements not needed in KobrA 2.0 are excluded using OCL constraints while new elements or properties are",
        "type": "NarrativeText"
    },
    {
        "element_id": "6e9a483a-2dd7-486e-b251-a06e418339c4",
        "metadata": {},
        "text": "KobrA2",
        "type": "Title"
    },
    {
        "element_id": "3002262e-a293-4787-8625-3e58840a0630",
        "metadata": {},
        "text": "Transformation Views SUM",
        "type": "Title"
    },
    {
        "element_id": "5d366cba-bf8a-4c8f-9dbe-131aaa7a5196",
        "metadata": {},
        "text": "Figure 3: KobrA 2.0 Top Level Packages.",
        "type": "Title"
    },
    {
        "element_id": "a8ad5078-6a4e-4990-bc86-c112a5921cbc",
        "metadata": {},
        "text": "introduced by specializing existing elements.",
        "type": "NarrativeText"
    },
    {
        "element_id": "cbb8cc88-27c2-4c4e-b9f0-cd09bdf15490",
        "metadata": {},
        "text": "The unique contribution of this paper is to elaborate on the structure of the KobrA 2.0 metamodel and how it is used to drive nAOMi. The three following sections each focus on one of the three main components of the metamodel \u2014 the SUM, the views and the transformations . This is followed by a brief overview of the OSM navigation paradigm in Sec- tion 5 before a small example of the approach is presented in Section 6. Section 7 then concludes the paper with related and future work.",
        "type": "NarrativeText"
    },
    {
        "element_id": "827b507d-893d-4c7c-915f-d17844bab237",
        "metadata": {},
        "text": "2. SUM PACKAGE",
        "type": "ListItem"
    },
    {
        "element_id": "5909af32-41bd-4ff4-bb03-950feb893b6c",
        "metadata": {},
        "text": "Figure 4 depicts the internal structure of the SUM pack- age which is based on the UML metamodel. There are three main subpackages, two containing the structural and behav- ioral constructs respectively, and one containing the con- straints that ensure that the metaclasses are used according to the KobrA conventions and rules.",
        "type": "NarrativeText"
    },
    {
        "element_id": "a9893231-473e-47b5-9cd1-f04346c28f75",
        "metadata": {},
        "text": "The Classes subpackage of the Structure package contains some of the most fundamental elements of the KobrA meta- model, such as Class and ComponentClass. The internal structure of this package is illustrated in Figure 5. Com- ponentClass represents objects with complex and reusable behaviors, while Class captures simple \u201cdata type\u201d objects that have only very simple or non-reusable behaviors. The modeler has to decide whether it is necessary to model a specific part of the system as a ComponentClass and include state charts and activity diagrams, or whether it is sufficient to use a Class (which is limited to using OCL constraints).",
        "type": "NarrativeText"
    },
    {
        "element_id": "519df77f-9657-4eec-bc3b-c6b876e01a54",
        "metadata": {},
        "text": "ComponentClass inherits (indirectly via Class) from Com-",
        "type": "Title"
    },
    {
        "element_id": "3eccff51-24ec-4751-ab2a-699416d8c8c4",
        "metadata": {},
        "text": "munications so it also has the isActive attribute. This makes",
        "type": "NarrativeText"
    },
    {
        "element_id": "af30a699-076c-4c90-91ec-7a8792f96a84",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "f65526f8-c3cd-4f1a-acbf-e962e0cf7daf",
        "metadata": {},
        "text": "KobrA2::SUM::Structure::Instances",
        "type": "Title"
    },
    {
        "element_id": "3ef56647-a849-4d76-8164-d21f8541e60e",
        "metadata": {},
        "text": "KobrA2::SUM::Behavior::ProtocolStateMachines",
        "type": "Title"
    },
    {
        "element_id": "e6da9d56-fd0f-4432-a8a1-d4aa7fc9d3f1",
        "metadata": {},
        "text": "I<<merge>> I v | 5 5 | KobrA2::SUM::Structure::Classes KobrA2::SUM::Behavior::Actions | | x a | <<merge>> |<<merge>> EEE | v ! | | KobrA2::SUM::Structure::Types KobrA2::SUM::Behavior::Activities | l I *\u00ae | | | | <<merge>> | | <<merge>> | | v | oh | KobrA2::SUM::Structure::Elements I KobrA2::SUM::Behavior::Common | | | | | | | | A <<merge>> <<merge>> | KobrA2::SUM::Constraint : t | i \u2014 7K |<<merge>> <<merge>>",
        "type": "NarrativeText"
    },
    {
        "element_id": "f3a64ad1-277b-469b-a57d-bacb11b6fb03",
        "metadata": {},
        "text": "KobrA2::SUM::Constraint::Common|",
        "type": "Title"
    },
    {
        "element_id": "c3849c0d-886e-42b0-bf5f-0d448c8f8e71",
        "metadata": {},
        "text": "7",
        "type": "UncategorizedText"
    },
    {
        "element_id": "3b7903c7-4185-428f-afc7-6a92b8e19a79",
        "metadata": {},
        "text": "| <<merge>>",
        "type": "Title"
    },
    {
        "element_id": "964b2766-184c-4d2c-9814-0474613c79c5",
        "metadata": {},
        "text": "|",
        "type": "UncategorizedText"
    },
    {
        "element_id": "ef49d38c-4274-4233-9adc-9ee2c3903024",
        "metadata": {},
        "text": "|",
        "type": "UncategorizedText"
    },
    {
        "element_id": "01746a58-fbdf-400a-a1a0-2a801d1ef0f1",
        "metadata": {},
        "text": "1 |",
        "type": "UncategorizedText"
    },
    {
        "element_id": "13c113ca-6417-402e-9df5-8e5cfb9ff11c",
        "metadata": {},
        "text": "<<merge>>",
        "type": "Title"
    },
    {
        "element_id": "e6df6662-2d48-4a8c-96a9-22244b499692",
        "metadata": {},
        "text": "x | | | | | | | | | | | | | | |",
        "type": "UncategorizedText"
    },
    {
        "element_id": "1a53ac6c-af91-4883-8a74-bc75fd5cc9be",
        "metadata": {},
        "text": "KobrA2::SUM::Constraint::Structural",
        "type": "Title"
    },
    {
        "element_id": "0dbdf77e-3b28-4070-bad1-011a7e689f55",
        "metadata": {},
        "text": "KobrA2::SUM::Constraint::Behavioral",
        "type": "Title"
    },
    {
        "element_id": "adba50fd-1c7d-4b06-b5c8-ad47b694c123",
        "metadata": {},
        "text": "Figure 4: KobrA 2.0 SUM Package.",
        "type": "Title"
    },
    {
        "element_id": "05fe7bcc-7022-40e6-9183-b8bab676c71c",
        "metadata": {},
        "text": "it possible to model whether its instances are active or pas- sive. Active objects, which can be used to model threads and processes (([8] p. 438), start to execute their behavior as soon as they are created and perform operations spontaneously. A ComponentClass may exhibit complex behavior. In Ko- brA, this behavior may be specified in the form of UML State Diagrams (defining acceptable operation invocation sequences), and in the form of Activities (defining algorithms of operations). UML Interaction elements (in sequence dia- grams) can be derived from the activity elements and thus are not included in the SUM. As KobrA aims to facilitate automatic checking of allowed sequences of operation calls, Protocol State Machines are supported instead of general state machines. Since the latter include a large variety of elements not needed for specifying acceptable operation se-",
        "type": "NarrativeText"
    },
    {
        "element_id": "8ceee5b3-ced5-4d02-aec9-6a2e4ecd7433",
        "metadata": {},
        "text": "quences or automatic checking, OCL constraints are used to prohibit the use of unwanted features.",
        "type": "NarrativeText"
    },
    {
        "element_id": "a5f682ad-89c8-40e8-bae5-3c89a4ab8c33",
        "metadata": {},
        "text": "context ComponentClass",
        "type": "Title"
    },
    {
        "element_id": "d378e008-bc5d-45f0-9d66-a51d280c5b99",
        "metadata": {},
        "text": "-- only allow Activity elements or ProtocolStateMachines ownedBehavior ->forAll (oclIsKindOf(Actitivity) or oclIsKind0f (ProtocolStateMachine) )",
        "type": "UncategorizedText"
    },
    {
        "element_id": "5bd6e98e-ff0b-474b-a7d7-83ffea7ccd33",
        "metadata": {},
        "text": "inv:",
        "type": "Title"
    },
    {
        "element_id": "33d342f5-1327-439a-8da0-8ad6b60c6fa5",
        "metadata": {},
        "text": "For example, since KobrA has no concept of roles for com- ponents, the use of role also needs to be prohibited. The part association refers to owned properties of components whose attribute isComposite is true. As KobrA uses associations like nests and creates for components, part, required and provided are not needed. Connectors (i.e. delegation and assembly) are not used in KobrA either so ownedConnector is excluded.",
        "type": "NarrativeText"
    },
    {
        "element_id": "824af0d9-3d39-43cc-834a-c0143b288fc2",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "7291bad2-8380-4eb9-b4ed-78f3c06d2a83",
        "metadata": {},
        "text": "KobrA2::SUM::Structure::Classes",
        "type": "Title"
    },
    {
        "element_id": "fbe57ac6-92f1-4da8-bf27-1d9516f7647d",
        "metadata": {},
        "text": "UML::CommonBehaviors::Communications::Class",
        "type": "Title"
    },
    {
        "element_id": "48b697e9-c453-4a9d-8d4c-1dd315f749ad",
        "metadata": {},
        "text": "+class +ownedAttribute 0.1 *",
        "type": "Title"
    },
    {
        "element_id": "dcb44375-ef53-4325-95ec-deeaa5fac0a8",
        "metadata": {},
        "text": "+powertype 0.1",
        "type": "Title"
    },
    {
        "element_id": "84ad0945-4942-4b25-94ff-295d91d8806d",
        "metadata": {},
        "text": "+componentClass {subsets component}",
        "type": "Title"
    },
    {
        "element_id": "c95d2ec9-27ee-4668-9cea-beeae94d23cf",
        "metadata": {},
        "text": "+packagedElement",
        "type": "Title"
    },
    {
        "element_id": "c1946a52-c6a6-4db1-97a7-51fecae44678",
        "metadata": {},
        "text": "+class +ownedOperation",
        "type": "Title"
    },
    {
        "element_id": "a641cbef-2dfe-4f69-9c5e-284a9490c7c2",
        "metadata": {},
        "text": "UML::Component::PackagingComponents::Component",
        "type": "Title"
    },
    {
        "element_id": "59428768-5375-43ee-ad4f-5af9645e30cb",
        "metadata": {},
        "text": "+supplier *",
        "type": "Title"
    },
    {
        "element_id": "5bee9788-e408-4c19-95a0-743df279f6b5",
        "metadata": {},
        "text": "0..1 a",
        "type": "UncategorizedText"
    },
    {
        "element_id": "c9086e02-8230-4149-b8a7-49a7b3448f71",
        "metadata": {},
        "text": "+/superClass",
        "type": "Title"
    },
    {
        "element_id": "32dde099-21d7-4c2f-af07-c2b326008810",
        "metadata": {},
        "text": "1 +supplierUsage {subsets supplierDependency}",
        "type": "Title"
    },
    {
        "element_id": "327814fa-bfba-499e-a4a7-91c267516d07",
        "metadata": {},
        "text": "+client * 4.\" +clientUsage {subsets clientDependency}",
        "type": "Title"
    },
    {
        "element_id": "8b73bb4a-b1d5-48e4-99de-f7f560adb81b",
        "metadata": {},
        "text": "Figure 5: KobrA 2.0 Classes Package.",
        "type": "Title"
    },
    {
        "element_id": "72114eaf-ef47-42ee-94e6-885d3f79a381",
        "metadata": {},
        "text": "context ComponentClass",
        "type": "Title"
    },
    {
        "element_id": "2e58bcb7-3c79-4caa-b632-173676323f04",
        "metadata": {},
        "text": "inv: role->union(part)->union(ownedConnector) ->union(collaborationUse)-> union(representation) ->union (realization) ->union (required)",
        "type": "NarrativeText"
    },
    {
        "element_id": "062177b6-ade9-42d4-b085-c228000388ca",
        "metadata": {},
        "text": ">union (provided) ->isEmpty ()",
        "type": "ListItem"
    },
    {
        "element_id": "e70a7235-29f3-4c57-8a68-3ad90b578338",
        "metadata": {},
        "text": "3. VIEWS PACKAGE",
        "type": "ListItem"
    },
    {
        "element_id": "e63b2de1-1ede-48ab-b708-32c3b994bc0b",
        "metadata": {},
        "text": "The structure of the Views package is illustrated in Figure 6. Again, since most of the views defined in KobrA 2.0 are based on UML diagrams, the view metamodels have similar elements to the SUM metamodel. The big difference to the SUM is that there are no restrictions on the use of the view metamodel elements. For instance, views for a particular purpose such as supporting model checkers can be supported by adding elements unrelated to the UML.",
        "type": "NarrativeText"
    },
    {
        "element_id": "cfbb6bb7-1837-479f-8a2f-88b7d7f50649",
        "metadata": {},
        "text": "The substructure of the Views package reflects the types and organization of the KobrA views according to the view \u201cdimensions\u201d supported in nAOMi (cf. example in Section 6). At the top level, the Views package is thus decomposed into the Specification and Realization options of the encap- sulation dimension. These, in turn are both decomposed into the Structural, Behavioral and Operational options of the Projection dimension. Finally, with the exception of the behavioral option, these are also all subdivided into the Service and Type options of the granularity dimension. This",
        "type": "NarrativeText"
    },
    {
        "element_id": "41b4246a-6ed0-46a0-89cf-d38b37cf7b66",
        "metadata": {},
        "text": "dimension, with its two options, is an addition to the original version of KobrA.",
        "type": "NarrativeText"
    },
    {
        "element_id": "9bb49b04-2368-4ff0-b153-0e8ecd9be292",
        "metadata": {},
        "text": "The Service view shows the direct, publicly visible rela- tionships of the subject ComponentClass to other Compo- nentClasses, while the Type view shows the publicly visi- ble relationships of the subject to simple Classes. As with the SUM, constraints have been defined to control what can go into each view and when they are well formed. For ev- ery view, a constraint enumerates all allowed elements (not shown in this paper).",
        "type": "NarrativeText"
    },
    {
        "element_id": "e7da573c-b0cb-4fca-a47e-0262811d6124",
        "metadata": {},
        "text": "In the following, some of the other constraints for the Service view are elaborated. Since this view is a black-box view, the internals of ComponentClasses (nestedClassifier ) are not shown.",
        "type": "NarrativeText"
    },
    {
        "element_id": "cd08f28f-4f8e-4b43-9910-69087cf9fdd8",
        "metadata": {},
        "text": "context ComponentClass -- no nested classifiers, no protocol inv: nestedClassifier->union(protocol) ->isEmpty ()",
        "type": "Title"
    },
    {
        "element_id": "7a27e799-204a-48d8-9777-2d67523fff23",
        "metadata": {},
        "text": "Classes are only allowed if they are generalizations of Com- ponentClasses, (or any of its superclasses, since a Compo- nentClass may inherit from a class as shown in the con- straints with context Class. The following invariants ensure that only publicly visible attributes and operations are in this view, for both classes and ComponentClasses (which inherit from Class).",
        "type": "NarrativeText"
    },
    {
        "element_id": "5ceee10c-b3e7-45bc-ac43-90a62d84e07f",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "3d3bbaf3-8447-424d-abe4-921e40cbecc8",
        "metadata": {},
        "text": "Views |",
        "type": "Title"
    },
    {
        "element_id": "cf897411-c615-4f6e-8f2f-2bed72a8cc13",
        "metadata": {},
        "text": "Specification ]",
        "type": "Title"
    },
    {
        "element_id": "faee45ea-ad21-4e57-93fd-9d86850b783f",
        "metadata": {},
        "text": "Structural |",
        "type": "Title"
    },
    {
        "element_id": "9200a9d4-39b9-4349-80d6-cb226c875502",
        "metadata": {},
        "text": "Behavioral |",
        "type": "Title"
    },
    {
        "element_id": "63639ac9-43a6-40ec-aebc-725c97700879",
        "metadata": {},
        "text": "|",
        "type": "UncategorizedText"
    },
    {
        "element_id": "485357c6-9f02-410a-8177-44f0729f95d9",
        "metadata": {},
        "text": "Instance",
        "type": "Title"
    },
    {
        "element_id": "51830594-f2a9-4f1b-83c3-f9b32cdeff28",
        "metadata": {},
        "text": "Service",
        "type": "Title"
    },
    {
        "element_id": "3bd964d5-f1bc-41ca-93fb-8a3b6ddf6b84",
        "metadata": {},
        "text": "Realization |",
        "type": "Title"
    },
    {
        "element_id": "c2d16b79-16d4-4e2b-b21d-8aba50ea17a0",
        "metadata": {},
        "text": "Se d P|",
        "type": "Title"
    },
    {
        "element_id": "b26a125b-7db6-46af-9f0a-ed2d28bf3f6d",
        "metadata": {},
        "text": "Protocol",
        "type": "Title"
    },
    {
        "element_id": "d9e0d0c3-7fd7-4d3a-9ca8-6ba0b2422211",
        "metadata": {},
        "text": "<<import>> |",
        "type": "Title"
    },
    {
        "element_id": "80acf5b6-71e2-434b-8d2f-76654d255b46",
        "metadata": {},
        "text": "Structural |",
        "type": "Title"
    },
    {
        "element_id": "c349858b-8f8b-43b1-80db-5c06ab844a93",
        "metadata": {},
        "text": "\u2014 \u2014 +> ConcreteSyntax",
        "type": "Title"
    },
    {
        "element_id": "f4cc5177-00de-4cc5-ac8d-73267df88681",
        "metadata": {},
        "text": "Operational",
        "type": "Title"
    },
    {
        "element_id": "5983ccdb-53c8-4915-aa92-71c062282e64",
        "metadata": {},
        "text": "Service |",
        "type": "Title"
    },
    {
        "element_id": "631dc547-ddf4-4b65-9156-7d909dfc7eab",
        "metadata": {},
        "text": "| | Class Instance Subject ==4 <cmerge>> | | | | | Service Type Type",
        "type": "UncategorizedText"
    },
    {
        "element_id": "29ca1c59-a6a8-4413-b705-c795b11026a4",
        "metadata": {},
        "text": "<<import>>",
        "type": "Title"
    },
    {
        "element_id": "fad301b2-7d70-43f3-b69a-4271c1033870",
        "metadata": {},
        "text": "KobrA2::Views::Derived",
        "type": "Title"
    },
    {
        "element_id": "c7283b52-eb45-4a4c-967c-fd825702b0f6",
        "metadata": {},
        "text": "ComponentClassDependencies",
        "type": "Title"
    },
    {
        "element_id": "08660857-51d6-424e-9b16-9ce4fdab5529",
        "metadata": {},
        "text": "__ <<impor>>",
        "type": "UncategorizedText"
    },
    {
        "element_id": "3628d266-3db2-4cf4-a38f-9b2e3709b2f3",
        "metadata": {},
        "text": "OperationDependencies",
        "type": "Title"
    },
    {
        "element_id": "4ae79108-cfa7-4715-8bc1-d6a54a31d02e",
        "metadata": {},
        "text": "Figure 6: KobrA 2.0 Views package nesting.",
        "type": "Title"
    },
    {
        "element_id": "0fcafab0-68f8-41bd-a784-7324c6960f5c",
        "metadata": {},
        "text": "context Class",
        "type": "Title"
    },
    {
        "element_id": "e975f8d2-7340-482f-87ae-3c3cd8d8d1a8",
        "metadata": {},
        "text": "-- only allow classes that are direct or indirect generalizations of ComponentClasses in this view",
        "type": "NarrativeText"
    },
    {
        "element_id": "263b8f41-a94b-418b-84c4-afaa238c5081",
        "metadata": {},
        "text": "def: ccGeneralization : generalization.specific-> exists (oclIsKindOf (ComponentClass))",
        "type": "Title"
    },
    {
        "element_id": "56b784b7-8b79-43f1-8de2-da1875c500c9",
        "metadata": {},
        "text": "inv: generalization. specific->select (ocllsTypeOf ( Class))->exists(s|s.ccGeneralization)",
        "type": "Title"
    },
    {
        "element_id": "5bbeef0a-5cf1-4852-9832-90774fa03d55",
        "metadata": {},
        "text": "or ccGeneralization",
        "type": "Title"
    },
    {
        "element_id": "e68f2e73-b6a4-462b-bf9f-ad76b7526c66",
        "metadata": {},
        "text": "-- only public attributes in this view",
        "type": "NarrativeText"
    },
    {
        "element_id": "be006131-9e19-4585-b11f-be4b9a9ff9a4",
        "metadata": {},
        "text": "inv: ownedAttribute ->forAll (visibility=#public)",
        "type": "Title"
    },
    {
        "element_id": "cfe37328-09aa-4d73-98d8-bbdbbe3bff9f",
        "metadata": {},
        "text": "-- only public Operations are allowed in the specification",
        "type": "NarrativeText"
    },
    {
        "element_id": "1218eb2f-13fb-4eee-905b-13e329458675",
        "metadata": {},
        "text": "inv: ownedOperation->forAll(visibility=#public)",
        "type": "Title"
    },
    {
        "element_id": "627c9efa-5e98-4efd-a77b-2e5a7e10c1cf",
        "metadata": {},
        "text": "Only operation signatures are shown in this view, so pre-, post- and bodyconditions, as well as activities are omitted,",
        "type": "NarrativeText"
    },
    {
        "element_id": "bfb9c1a2-6afe-4e06-ad27-d8cfeb2b8db1",
        "metadata": {},
        "text": "which is reflected in the last constraint.",
        "type": "NarrativeText"
    },
    {
        "element_id": "16c70525-6bb2-44dc-8e0e-cc328bab804e",
        "metadata": {},
        "text": "context Operation",
        "type": "Title"
    },
    {
        "element_id": "3fc2cd3f-d8a8-4811-9da0-38101909195e",
        "metadata": {},
        "text": "-- only the signature of the Operation is shown, not its behavior (role name \"method\" refers to the Activities of the operation), or dependencies",
        "type": "NarrativeText"
    },
    {
        "element_id": "abf80fd9-68f4-4c8b-885e-2ec48a5dd24c",
        "metadata": {},
        "text": "inv: method->union (precondition) ->union (body) ->union( postcondition)->isEmpty ()",
        "type": "Title"
    },
    {
        "element_id": "b25fcd78-d415-4aed-a0f2-3066b05c6949",
        "metadata": {},
        "text": "4. TRANSFORMATIONS PACKAGE",
        "type": "ListItem"
    },
    {
        "element_id": "30d6c1ac-73cd-4e77-9a9f-c115c2ab42ec",
        "metadata": {},
        "text": "The package AllViews provides the foundation for speci- fying the transformations between the SUM and the views in both directions. Part of the package\u2019s contents are shown in Figure 7. The Abstraction concept (which is in fact a",
        "type": "NarrativeText"
    },
    {
        "element_id": "abee41c4-5e8e-426c-b18e-6278b6018c5a",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "a72ea9d0-70c6-4943-8028-bbfd6f16badc",
        "metadata": {},
        "text": "KobrA2::Transformation::Common::AllViews|",
        "type": "Title"
    },
    {
        "element_id": "bcb2d906-433f-4a21-84ef-7f0f24581b4b",
        "metadata": {},
        "text": "0..1",
        "type": "UncategorizedText"
    },
    {
        "element_id": "c2b02c73-fa9f-4005-a6a9-24acaff6c466",
        "metadata": {},
        "text": "+abstraction | 1..* +abstraction| 1",
        "type": "Title"
    },
    {
        "element_id": "04a80ced-d2f3-4010-9a86-5b032a222d0e",
        "metadata": {},
        "text": "\u2018subsets supplierDependency}",
        "type": "Title"
    },
    {
        "element_id": "46886d7d-0d2d-4c6e-9651-21816c6a113b",
        "metadata": {},
        "text": "{subsets supplier}",
        "type": "NarrativeText"
    },
    {
        "element_id": "343079c8-722c-4591-ac2d-5d47e1fca41b",
        "metadata": {},
        "text": "{subsets clientDependency}",
        "type": "Title"
    },
    {
        "element_id": "3baf8143-9cb5-4ba3-a1d8-d830b2cb3679",
        "metadata": {},
        "text": "{subsets client}",
        "type": "Title"
    },
    {
        "element_id": "91235611-563e-4d50-9c50-3f0dcbd56ece",
        "metadata": {},
        "text": "{subsets mapping}",
        "type": "NarrativeText"
    },
    {
        "element_id": "61eccf5e-bc10-47cf-9740-aca103d191df",
        "metadata": {},
        "text": "dependency reused from the UML but with additional con- straints) plays the key role in relating elements from the SUM to elements of a view. Abstraction is actually mapped to ExpressionInOcl. When appearing in transformations, the equals sign links elements in the SUM to the respective elements in the view, and vice versa. For instance, equal- ity of the general meta-association of a Generalization in a transformation invariant means that, when following gen- eral, there must be an element in the SUM and in the view for which similar transformation expressions are specified. In the case of KobrA 2.0, which has many projections that just select a subset of elements using one-to-one abstrac- tions, this allows concise declarative TransformationExpres- sions. Together with the view constraints, a CASE tool can be implemented which uses a transformation language of the implementor\u2019s choice, for instance the Atlas Transformation Language (ATL) [11] or QVT [9]. The role names se and ve are short for SumElement and ViewElement, respectively. These roles subset the client and supplier roles from the UML.",
        "type": "NarrativeText"
    },
    {
        "element_id": "cb50b007-7e88-453b-bd50-f799b2045c44",
        "metadata": {},
        "text": "SUM elements are translated into UML elements with stereotypes, so that the views are easy to manage for de- velopers familiar with the UML. The bidirectional mappings between stereotyped view elements and non-stereotyped SUM elements are expressed in the constraints of the Association- Abstraction, a subclass of the Abstraction from the AllViews package. This is also an example of a transformation which is reused in other views.",
        "type": "NarrativeText"
    },
    {
        "element_id": "63f3b8ee-a515-4da6-8819-f0cb62f75cad",
        "metadata": {},
        "text": "context AssociationAbstraction",
        "type": "Title"
    },
    {
        "element_id": "e8f03c94-2c6c-4769-ab4c-93986bd2b198",
        "metadata": {},
        "text": "inv: ve.memberEnd = se.memberEnd inv: ve.ownedEnd = se.ownedEnd ivn: ve.navigableOwnedEnd = se.navigableOwnedEnd",
        "type": "NarrativeText"
    },
    {
        "element_id": "c36bada7-d0cc-4ac7-8e01-ade9ef411583",
        "metadata": {},
        "text": "inv: se.oclIsKindOf (Acquires) implies ve. hasStereotype(\u2019 acquires \u2019)",
        "type": "NarrativeText"
    },
    {
        "element_id": "110500cd-6102-48c1-91cd-424fe5c26a8f",
        "metadata": {},
        "text": "inv: ve.hasStereotype(\u2019acquires\u2019) implies se. oclIsKindOf (Aquires)",
        "type": "NarrativeText"
    },
    {
        "element_id": "8e4b3edf-70e7-4a2a-a08c-582d7f6f4b99",
        "metadata": {},
        "text": "inv: se.oclIsKindOf(Nests) implies ve.hasStereotype(\u2019 nests\u2019)",
        "type": "NarrativeText"
    },
    {
        "element_id": "47e846e8-ea92-4e94-b21d-9519251ffa44",
        "metadata": {},
        "text": "Figure 7: Transformation abstractions.",
        "type": "Title"
    },
    {
        "element_id": "37b19ea4-dbc0-4cf1-b23b-b239521fa00b",
        "metadata": {},
        "text": "inv: ve.hasStereotype(\u2019nests\u2019) implies se.oclIsKind0f (Nests)",
        "type": "NarrativeText"
    },
    {
        "element_id": "fb0b4a74-8b4f-4911-b363-9c02265ef11c",
        "metadata": {},
        "text": "inv: se.oclIsKindOf(Creates) implies ve.hasStereotype (creates \u2019)",
        "type": "NarrativeText"
    },
    {
        "element_id": "9c9e4e04-ae2c-4d44-bbbd-1912286dce70",
        "metadata": {},
        "text": "inv: ve.hasStereotype(\u2019creates\u2019) implies se oclIsKindOf (Creates)",
        "type": "NarrativeText"
    },
    {
        "element_id": "adcb3970-26e0-4c0d-9b36-befe27e1dbd1",
        "metadata": {},
        "text": "Figure 8 shows the main elements involved in the trans- formation of the black box structural view for Component- Classes. The first transformation constraint is on the view and declares the starting point for the transformation. It states that the subject ComponentClass and its generaliza- tions (using a SUM utility function, superClosure) are in the view.",
        "type": "NarrativeText"
    },
    {
        "element_id": "db8bcd7b-8d52-4632-9031-732a6ff3653a",
        "metadata": {},
        "text": "The following transformation rules illustrate how to create the output (i.e. view) elements from the input (i.e. SUM) el- ements, such as the publicly visible attributes and operations of the ComponentClass and the acquired ComponentClasses. The first constraint for ComponentClassAbstraction states that references to potential general classes (and Component- Classes) of ComponentClasses are mirrored in the view. In addition, ComponentClasses will be shown with the corre- sponding stereotypes. The ComponentClass owns various types of associations, so in this view only the acquires asso- ciations are selected (whose transformation rules are cov- ered in the common transformation packages).For classes and ComponentClasses, only publicly visible attributes and operations appear in the view. Class invariants are also copied. Classes that may appear in this view (e.g. as gener- alizations of ComponentClasses) may have a powertype (role name powertypeExtent) which will be displayed.",
        "type": "NarrativeText"
    },
    {
        "element_id": "df52d99c-754d-4bb1-b8c9-fd5efbf89daf",
        "metadata": {},
        "text": "The last transformation statement copies the class refer- ences of operations. As with all views, the transformation rules, the common transformation statements (which also cover operations) and the view constraints serve as a speci- fication for the implementation of a view. Individual CASE tools can use different implementation techniques as long as they conform to the semantics of these rules and constraints.",
        "type": "NarrativeText"
    },
    {
        "element_id": "233cfa28-75d8-40a4-8540-6ef6c13131a3",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "f784b6a0-fa69-42da-a3f0-cf8f048a9a14",
        "metadata": {},
        "text": "Figure 8: Transformation to the Specification Structural Service View.",
        "type": "Title"
    },
    {
        "element_id": "cf20a60b-e9e1-4f57-9db1-a3f61b0131a6",
        "metadata": {},
        "text": "context KobrA2::Views::Subject:: SpecificationStructuralClassService",
        "type": "Title"
    },
    {
        "element_id": "fdb3fa96-007a-4d05-ad72-80ddcb57c08d",
        "metadata": {},
        "text": "inv: ownedMember ->select (oclIsKindOf(Class)) = subject . superClosure ->union(subject. acquires superClosure)",
        "type": "NarrativeText"
    },
    {
        "element_id": "ee1dde0e-57dd-4830-a753-d7a4de2baca3",
        "metadata": {},
        "text": "context ComponentClassAbstraction",
        "type": "Title"
    },
    {
        "element_id": "16da9965-972b-458b-9705-c2c044a0c1f7",
        "metadata": {},
        "text": "inv: ve.superClass = se.superClass",
        "type": "Title"
    },
    {
        "element_id": "bde962d9-89d6-4872-805f-91c59af9781d",
        "metadata": {},
        "text": "inv: ve.hasStereotype(\u2019ComponentClass \u2019)",
        "type": "Title"
    },
    {
        "element_id": "95d395b5-fba7-4376-989b-8971b63f0b87",
        "metadata": {},
        "text": "inv: se.isSubject implies (ve.hasStereotype(\u2019subject >) and ve.ownedMember ->select (oclIsKindOf ( Association)) = se.ownedMember->select ( oclIsKindOf (Acquires)))",
        "type": "NarrativeText"
    },
    {
        "element_id": "862cd0c7-1667-48e0-81ed-c0c1f13c6fca",
        "metadata": {},
        "text": "context ClassAbstraction",
        "type": "Title"
    },
    {
        "element_id": "c35d38f2-b545-423f-a60a-9953b7e59b75",
        "metadata": {},
        "text": "inv: ve.ownedAttribute = se.ownedAttribute->select ( visibility=#public)",
        "type": "Title"
    },
    {
        "element_id": "d7d6f8f8-1779-47bd-b086-a8564b1868b4",
        "metadata": {},
        "text": "inv: ve.ownedOperation= se.ownedOperation->select ( visibility=#public)",
        "type": "Title"
    },
    {
        "element_id": "c47e0cae-659a-4a68-b4fb-2ffb74649083",
        "metadata": {},
        "text": "inv: ve.\u2018inv\u2019 = se.\u2018inv\u2019",
        "type": "NarrativeText"
    },
    {
        "element_id": "830adc14-0afc-4a5d-b9e6-e9bdd97c5a4d",
        "metadata": {},
        "text": "-- copy powertypeExtent that is only allowed for class",
        "type": "NarrativeText"
    },
    {
        "element_id": "bbabde3c-268c-48b7-b66e-923511e298c1",
        "metadata": {},
        "text": "inv: ve.powertypeExtent = se.powertypeExtent",
        "type": "Title"
    },
    {
        "element_id": "f1e444cc-3693-4b4e-aff4-a740b512c1a2",
        "metadata": {},
        "text": "context OperationAbstraction inv: ve.class = se.class",
        "type": "Title"
    },
    {
        "element_id": "d2933a84-546d-49c2-a811-5cfe6a43689d",
        "metadata": {},
        "text": "For the black box type view, only publicly visible at- tributes and operations of classes (as opposed to Compo- nentClasses) used by the subject can be seen. This is spec- ified in the first rule which defines owned members of the view and thus serves as the starting point of the transfor- mation. cbbTypes is a utility function defined in the SUM which computes the black box types by selecting the types of the subject\u2019s public attributes and parameter types of its public operations.",
        "type": "NarrativeText"
    },
    {
        "element_id": "3fd7da1b-bb4a-46d0-a57a-3155d0cc95ef",
        "metadata": {},
        "text": "Class invariants and potential powertypes and connections to the classes in this view are shown as well. There may also be Enumerations, for which the EnumerationLiterals are displayed.",
        "type": "NarrativeText"
    },
    {
        "element_id": "fc930fbc-94f2-4c48-a6b6-5dd6c2543fea",
        "metadata": {},
        "text": "The transformation rules for this view are almost the same as the realization transformation constraints from the pack- age Transformation::Realization::Structural::Class:: Type. The differences are the select(visibility=#public) statements for operations and attributes.",
        "type": "NarrativeText"
    },
    {
        "element_id": "6f63edd1-503d-41ae-a4bc-c99c4328473a",
        "metadata": {},
        "text": "context KobrA2::Views::Subject:: SpecificationStructuralClassType",
        "type": "Title"
    },
    {
        "element_id": "79f02456-0c86-4ee7-aa4e-a7ca071c7f3e",
        "metadata": {},
        "text": "inv: ownedMember ->select (oclIsKindOf(Class) or oclIsKindOf (\u2018Enumeration\u2019) or oclIsKindOf( Association)) = subject->union(subject.cbbTypes)",
        "type": "NarrativeText"
    },
    {
        "element_id": "92f77e8a-f8b3-4ad2-a3b4-cfdb51720ed9",
        "metadata": {},
        "text": "context ComponentClassAbstraction inv: se.isSubject implies ve.hasStereotype(\u2019subject\u2019)",
        "type": "Title"
    },
    {
        "element_id": "6015baa0-02d4-4211-9c6c-238d613cb563",
        "metadata": {},
        "text": "context ClassAbstraction inv: not se.oclIsKindOf(ComponentClass) implies (",
        "type": "NarrativeText"
    },
    {
        "element_id": "b82ea654-9771-43c9-adc4-22114314dd71",
        "metadata": {},
        "text": "ve.ownedAttribute = se.ownedAttribute->select ( visibility=#public) ve.ownedOperation = se.ownedOperation->select ( visibility=#public)) inv: ve.powertypeExtent = se.powertypeExtent inv: ve.superClass = se.superClass inv: \u2018ve.inv\u2019 = \u2018se.inv\u2019",
        "type": "UncategorizedText"
    },
    {
        "element_id": "3db9060f-e4d2-4cf4-919a-5484bf4f0a50",
        "metadata": {},
        "text": "context ComponentClassAbstraction inv: se.isSubject implies ve.hasStereotype(\u2019subject\u2019)",
        "type": "Title"
    },
    {
        "element_id": "889ac885-e6fa-4a78-aafb-642738762569",
        "metadata": {},
        "text": "context EnumerationAbstraction inv: ve.ownedLiteral = se.ownedLiteral",
        "type": "Title"
    },
    {
        "element_id": "ca5d19e7-44be-47a2-8d7b-bc22ba402a4b",
        "metadata": {},
        "text": "context EnumerationLiteralAbstraction inv: ve.specification = se.specification. stringInSignature",
        "type": "Title"
    },
    {
        "element_id": "bcc74902-cb06-49b9-9517-7a06ffa4bdd8",
        "metadata": {},
        "text": "5. NAVIGATION",
        "type": "ListItem"
    },
    {
        "element_id": "f2431e97-4487-46a0-a6b8-654948902197",
        "metadata": {},
        "text": "Most of today\u2019s tools use some combination of trees to organize the content of models as well as the views used to visualize a software system or component. In an any envi- ronment incorporating a number of different tools there is invariably a large number of different trees storing a het- erogeneous mix of artifacts including model elements (e.g. classes, instances, associations), diagrams (e.g. class dia- grams, state diagrams) and other artifact types (source code, XML files, configuration files ). To work with all the views in a traditional development environment, therefore, engineers typically have to learn about the organization structures of all the incorporated tools.",
        "type": "NarrativeText"
    },
    {
        "element_id": "f4c1b25c-55ee-4809-93f1-b19ae46b03df",
        "metadata": {},
        "text": "In contrast to conventional paradigms for organizing and navigating the many views used to visualize a system, OSM employs the metaphor of a multi-dimensional cube. More specifically, as illustrated in Figure 9, OSM regards dimen- sion of the underlying methodology as representing a differ- ent dimension of the cube, and each independently variable aspect of that dimension is a selectable dimension element. Selecting a view thus simply corresponds to selecting a single cell within the cube. In general, three types of dimensions are supported: static dimensions in which the number of",
        "type": "NarrativeText"
    },
    {
        "element_id": "4000abe8-a49d-4f0b-bb03-f72e6fcd4ccd",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "ded8a119-697c-4c67-94b5-0a83eb289e29",
        "metadata": {},
        "text": "Figure 9: Dimension-based navigation.",
        "type": "Title"
    },
    {
        "element_id": "21b9a284-d189-4071-8a2f-36f6bfd6b7a7",
        "metadata": {},
        "text": "selectable elements (i.e. coordinates) is fixed, dynamic di- mensions in which the number of elements is dynamic (i.e. derived from the SUM), and mixed dimensions which have both static and dynamic elements.",
        "type": "NarrativeText"
    },
    {
        "element_id": "0a242ae9-4a30-4693-8da2-fa7e594a66ca",
        "metadata": {},
        "text": "To support the OSM dimension based navigation metaphor",
        "type": "NarrativeText"
    },
    {
        "element_id": "46a1546a-165b-4ee6-86c3-47dc5966f9ee",
        "metadata": {},
        "text": "for KobrA, we defined the seven dimensions indicated on the left hand side of Figure 10 which is a sceenshot of nAOMI. The Abstraction dimension (not expanded here), which has three static dimension elements, PIM (platform independent model), PSM (platform specific model) and Code, captures the model-driven development concern of KobrA. The ver- sion dimension captures the state of the modeled system at specific points in time. The Component dimension, which has dynamic dimension elements defined by instances of the class ComponentClass in the SUM, captures the component- based development concern of KobrA. The Encapsulation dimension, which has two fixed ele- ments, supports the distinction between Specification (black box) and Realization (white box) views of components, while the Projection dimension with the fixed elements Structural, Operational and Behavioral covers the different information types. The Granularity dimension provides a finer grained istinction between views describing the types used by com- ponents (Type granularity) and views describing the required and provided interfaces (Service granularity). The Opera- tion dimension allows a selection of individual operations.",
        "type": "NarrativeText"
    },
    {
        "element_id": "d0010155-e223-46b2-bd86-e7b2efaf25ee",
        "metadata": {},
        "text": "In the ideal case, when all views are truly orthogonal, the choices that can be made in each dimensions are completely independent. However, this is very difficult to achieve in software engineering. The approach still works if the views are not completely orthogonal, but dependencies then occur between different choices in different dimensions, so that the decisions made in one dimensions may affect choices possi- ble in another dimension. This is best handled by giving dimensions a precedence ranking determined by the order in which they appear (the top being the highest). When an element in a dimension is selected, the tool automatically makes default selections for dimensions of lower precedence (ie. dimensions lower down) and disables selections that would navigate to cells (ie. views) which are not (yet) de- fined by the method at hand.",
        "type": "NarrativeText"
    },
    {
        "element_id": "3f3d484a-cf62-4470-a842-05031576b947",
        "metadata": {},
        "text": "6. SHOPPING CART EXAMPLE",
        "type": "ListItem"
    },
    {
        "element_id": "b123f747-f282-4433-83e2-e2ecbf200b04",
        "metadata": {},
        "text": "To show how a software system can be specified using nAOMiz, this section presents a case study based on a shop- ping cart system. A ShoppingCart component collects and",
        "type": "NarrativeText"
    },
    {
        "element_id": "2da63caa-ff74-4abd-8dad-cd6adaf2d98a",
        "metadata": {},
        "text": "@Dime & = || fd) PIM - ShoppingCart - Specification - Structural - Ser of\" El @& Fi) Ss \u00abmodel\u00bb Abstraction(PIM) e Version = latest a 3 (2013 Apro3, 09:01[ 4}|) = \u2014 2 (2013 Apr03, 08:50 = ||| | <CO\u2122PonentClass, subject\u00bb || Product \u00ab il) , ShoppingCart = \u00a9 price Component Ea products S] ShoppingCart G max S] ValidationService \u00a9 cost Encapsulation @ addProduct( p: Product) CreditCard @ Specification @ removeProduct( ) &) Realization @ checkOut( ) || G& number = S| | # pay() \u00a9 expireDate a \u00ae close( ) \u00a9 validationCode Structural * ||| | @ currentState( ) SG creditLimit Operational jj Behavioral x : = \u00abacquires\u00bb Granularity \u00abenumeration\u00bb S) Service =] state Type \u00abComponentClass\u00bb \u2014a S ValidationService = Empty = CollectingProducts all owned a : lidat @ = addProduct @ velidatet ) oo @ removeProduct | @ checkOut",
        "type": "NarrativeText"
    },
    {
        "element_id": "0f969b0e-1b54-49ab-8216-0d7d2e2b84c7",
        "metadata": {},
        "text": "Figure 10: Specification Structural View.",
        "type": "Title"
    },
    {
        "element_id": "bc16d3b7-727e-4871-aaa5-7b436721f8f4",
        "metadata": {},
        "text": "manages the products selected by users and supports pay- ment via a credit card. Figure 10 illustrates a structural view of the component.",
        "type": "NarrativeText"
    },
    {
        "element_id": "bd0ed432-7422-4549-8923-38579ed81c16",
        "metadata": {},
        "text": "In the dimension navigator on the left hand side, PIM was chosen for the \u201cAbstraction Level\u201d (not expanded in the screenshot). The second dimension is the state of the soft- ware system at a certain point in time. The picture shows that the latest available version was chosen. As with every choice in a dimension, it may influence the options in lower ranked dimensions. The component under consideration is the ShoppingCart, for which a black box view is selected in the next dimension. After the user selects the structural projection option and the service level granularity, the tool automatically chooses the option for all operations in the last dimension, as there is no editor registered for the other options.",
        "type": "NarrativeText"
    },
    {
        "element_id": "4d1448f4-3d6c-434b-b52a-68d2daf6d5f4",
        "metadata": {},
        "text": "The component under development is presented with the stereotype subject and its relationship to other components and classes is shown in the view, which corresponds to a cell of the multi-dimensional navigation cube, and is generated on-the-fly from the SUM when it is selected. The classes Product and CreditCard can be used as data types in the operations of the component.",
        "type": "NarrativeText"
    },
    {
        "element_id": "8e9bf208-c388-4233-908c-8ab2e21f4a81",
        "metadata": {},
        "text": "Figure 11 illustrates the operational view in which an operation can be formalized using pre- and postconditions. The precondition corresponds to the assumes clause in and the postcondition corresponds to the result clause. As in the UML, the precondition of an operation must be true when the operation is invoked and the postcondition must be true when the operation is finished. The operation addProduct in Figure 11 must be in state CollectingProducts or Empty when invoked. This is also visible in the behavioral view,",
        "type": "NarrativeText"
    },
    {
        "element_id": "a57eb1b5-4cb7-4ce5-b01d-76935fcdfada",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "b0a03bda-f7de-463e-accf-2e4d1f328987",
        "metadata": {},
        "text": "\u00ae PIM - ShoppingCart - Specification - Operational - Service - addProduct - Generic - Standard.k2opspec \u00a33",
        "type": "UncategorizedText"
    },
    {
        "element_id": "c643f0ce-affc-462a-849d-f13f6b1f9b1e",
        "metadata": {},
        "text": "Operation Information Name: ShoppingCart::addProduct (p : Product)",
        "type": "Title"
    },
    {
        "element_id": "2439c40c-07d0-49ff-86ae-934aa9b7c47c",
        "metadata": {},
        "text": "Constraint",
        "type": "Title"
    },
    {
        "element_id": "a1b8d495-95e3-45f1-9c22-a314dfc91a7c",
        "metadata": {},
        "text": "Precondition:",
        "type": "Title"
    },
    {
        "element_id": "9f21081e-00dc-4b24-ae77-8756ebc54515",
        "metadata": {},
        "text": "Body:",
        "type": "Title"
    },
    {
        "element_id": "6d0b7dbe-0d52-4fc3-94e3-a5d4c11b1d99",
        "metadata": {},
        "text": "Operation Specification Editor",
        "type": "Title"
    },
    {
        "element_id": "4e4029fd-cac4-4d8a-bb89-477738bb57b6",
        "metadata": {},
        "text": "currentState()=State::CollectingProducts or currentState()=State::Empty",
        "type": "Title"
    },
    {
        "element_id": "b3b16fa9-6ec6-445a-a812-ff902009e4d3",
        "metadata": {},
        "text": "Postcondition: currentState()=State::CollectingProducts and cost=cost@pre+p.price",
        "type": "Title"
    },
    {
        "element_id": "095a40fb-b90d-4764-ac76-60337077fb4a",
        "metadata": {},
        "text": "Figure 11: addProduct() Operation Specification.",
        "type": "Title"
    },
    {
        "element_id": "bc4324b0-524a-451a-8e84-071fc85acc2c",
        "metadata": {},
        "text": "since there are only two transitions with the operation ad- dProduct. Both leads to the state CollectingProducts which is also a postcondition of the operation. The second post- condition is that the cost attribute of the component must be increased by the price of the added product. The pre- and postcondition can be expressed using the OCL. The proper- ties of the component, states and operation parameters can be used to formalise the constraints like as in this example.",
        "type": "NarrativeText"
    },
    {
        "element_id": "517756ac-64d4-4200-a00c-f7e26d63acbb",
        "metadata": {},
        "text": "Figure 12 shows the publicly visible behaviour of the Shop- pingCart component with states and transitions. The condi- tional transitions map to operations of the component. Like every view, this view is also synchronized with the SUM so that it is guaranteed that its operations, states and proper- ties are consistent with those in the structural view.",
        "type": "NarrativeText"
    },
    {
        "element_id": "9c1fadbb-6a8f-4642-84fc-f7fc1042d27f",
        "metadata": {},
        "text": "@Dime = || fd) PIM - ShoppingCart - Specification - Behavioral - Service f%er",
        "type": "UncategorizedText"
    },
    {
        "element_id": "b6a99384-340e-4972-8a63-a82be917c6aa",
        "metadata": {},
        "text": "Abstraction(PIM)|__\u00a9",
        "type": "Title"
    },
    {
        "element_id": "e3cac536-349c-49a3-9cf2-2a3d8df12e95",
        "metadata": {},
        "text": "C StateMachine Version [limit OK but card not OK] pay latest a",
        "type": "Title"
    },
    {
        "element_id": "728cce7b-4748-42f0-a206-fa7d40c7fa95",
        "metadata": {},
        "text": "3 (2013 Apr 03, 09:01] [products=1] removeProduct",
        "type": "Title"
    },
    {
        "element_id": "5042a22f-cb24-4098-af3e-cba0b4271a67",
        "metadata": {},
        "text": "2 (2013 Apr03, 08:50 ~ ||| | @ Empty 4 ee [limit OK and card OK] pay",
        "type": "NarrativeText"
    },
    {
        "element_id": "813c27f3-71c1-4d48-9de6-21a38997452d",
        "metadata": {},
        "text": "@ Checkout",
        "type": "Title"
    },
    {
        "element_id": "a58dc712-4f69-441e-8059-d7923f78d3f3",
        "metadata": {},
        "text": "Component ] ShoppingCart S] ValidationService",
        "type": "Title"
    },
    {
        "element_id": "2c3ca41d-1897-4c6d-bb5f-6fe9354e7038",
        "metadata": {},
        "text": "[products=1] removeProduct",
        "type": "Title"
    },
    {
        "element_id": "1633a50a-b941-4746-b222-22faf6dfd2a8",
        "metadata": {},
        "text": "Encapsulation @ Specification",
        "type": "Title"
    },
    {
        "element_id": "fccdc9ef-a391-4fc4-8b0b-da16f219cb74",
        "metadata": {},
        "text": ") Realization 7",
        "type": "Title"
    },
    {
        "element_id": "29fb9526-b043-44f2-bfe3-9ef71a5b34fb",
        "metadata": {},
        "text": "Projection Structural a Operational ] Behavioral a",
        "type": "Title"
    },
    {
        "element_id": "98b7127d-b3b3-4db7-949b-1895a61d1d62",
        "metadata": {},
        "text": "[limit not OK] pay",
        "type": "Title"
    },
    {
        "element_id": "44c18c20-0c64-4381-9f18-6321a3fb6a33",
        "metadata": {},
        "text": "addProduct Granularity",
        "type": "Title"
    },
    {
        "element_id": "7dd085e6-9849-48a8-944e-2f8a04f29a95",
        "metadata": {},
        "text": "S] Service Type @ CollectingProducts",
        "type": "Title"
    },
    {
        "element_id": "8d96b2e9-4b2e-4ddd-97a1-ff6d2cbb3cb9",
        "metadata": {},
        "text": "[products>1] removeProduct",
        "type": "NarrativeText"
    },
    {
        "element_id": "2fe10cdc-040e-439c-a99f-bc84dc4f6dea",
        "metadata": {},
        "text": "Operation all owned a",
        "type": "NarrativeText"
    },
    {
        "element_id": "84d85a57-d4d6-4976-8f86-d920801aff46",
        "metadata": {},
        "text": "@ = addProduct @ removeProduct|* W\u00ae checkOut La",
        "type": "Title"
    },
    {
        "element_id": "d3af11f4-a7d6-4448-a88c-9669b6442aa4",
        "metadata": {},
        "text": "addProduct",
        "type": "Title"
    },
    {
        "element_id": "0bab3ca4-f7c3-4a08-83b3-701a3815ca71",
        "metadata": {},
        "text": "[products>1] removeProduct",
        "type": "NarrativeText"
    },
    {
        "element_id": "b7841b59-18cc-410d-976e-e574699500cc",
        "metadata": {},
        "text": "Figure 12: Specification Behavioral Model.",
        "type": "Title"
    },
    {
        "element_id": "f97310dd-2391-46d3-beaa-b8dc58256a80",
        "metadata": {},
        "text": "Although the operational view seems to be similar to the behavioral view because of the overlapping information within",
        "type": "NarrativeText"
    },
    {
        "element_id": "016d7c14-0709-4fb5-8abc-4e1d7c11c72e",
        "metadata": {},
        "text": "them, there are significant differences. The focus of the op- erational view is on a precise formal definition of an opera- tion of acomponent. The operations can be enriched by pre- and postconditions which can be defined using complex OCL statements, that formalize the complete behavior of an op- eration. The additional information in the OCL statements can be used for code generation and documentation.",
        "type": "NarrativeText"
    },
    {
        "element_id": "c9ee3d1d-d138-42de-b3eb-1913d0f45959",
        "metadata": {},
        "text": "7. CONCLUSION",
        "type": "ListItem"
    },
    {
        "element_id": "c71bf2ce-6632-4b00-93b2-5f7927e0068f",
        "metadata": {},
        "text": "At the beginning of the paper we identified three funda- mental hypothesis upon which the notion of OSM is based \u2014 (a) that it is feasible to integrate the many different kinds of artifacts used in contemporary software engineering meth- ods within a single coherent methodology in which they are treated as views, (b) that it is feasible to create an effi- cient and scalable way of supporting these views by gener- ating them dynamically, on-the-fly, from a Single Underly- ing Model (SUM) using model-based transformations and (c) that it is feasible to provide an intuitive metaphor for navigating around these many views by adapting the ortho- graphic projection technique underpinning the CAD tools used in other engineering disciplines.",
        "type": "NarrativeText"
    },
    {
        "element_id": "7f17fef8-d9e7-441e-8f37-a96e61351bf6",
        "metadata": {},
        "text": "The prototype tool, nAOMi, described in this paper rep- resents the first step towards demonstrating the validity of these hypotheses and showing that OSM is a viable approach to software engineering. Of the three hypotheses, (a) and (c) are most convincingly demonstrated by the prototype, since it shows that it is indeed possible to support all the views of the KobrA method within a single navigation metaphor. The prototype tool does not demonstrate the validity of hy- pothesis (b) to the same extent as the others due to its small size. Although it demonstrates the feasibility of gen- erating views from the SUM and vice-versa, the question of whether such an approach scales up to large environments is still open.",
        "type": "NarrativeText"
    },
    {
        "element_id": "55924d31-1f85-47e7-9c64-ac5421de24e2",
        "metadata": {},
        "text": "Although nOAMi is the only tool developed with the spe- cific aim of supporting KobrA-based OSM, several other tools and methods have similar properties or aims. For example, Glinz et al. [10] describe a tool with a fisheye zooming algorithm which lets the user view a model with varying amounts of detail depending on the context. It has to be investigated whether it is possible to combine the fish- eye zooming concept with the dimension-based navigation paradigm. While the KobrA 2.0 implementation of nAOMi heavily uses UML diagrams for developers, Glinz et al. use",
        "type": "NarrativeText"
    },
    {
        "element_id": "7845a80f-d3ab-4991-b471-e8dd2ba9b0bf",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "40c9fde1-9777-4625-afea-e649682dd623",
        "metadata": {},
        "text": "custom diagram types, e.g. for structural and behavioral views.",
        "type": "NarrativeText"
    },
    {
        "element_id": "c5e76cbf-19dd-47ce-9773-d55c21dd9aa5",
        "metadata": {},
        "text": "An approach which also emphasizes the description of for- mal consistency rules (correspondences) between views is RM-ODP [5][6]. However, this approach does not explic- itly mention the notion of a SUM and thus implies that consistency rules should be defined in a pairwise fashion be- tween individual pairs of views. ArchiMate [7], which com- plements TOGAF [12], is an enterprise architecture mod- eling language which offers two orthogonal \u201ddimensions\u201d for modeling, (business, architecture, and technology) layers and (informational, behavioral and structural) aspects and also suggests two more dimensions, purpose and abstraction level. However, as many of these views span multiple choices of a single \u201cdimension\u201d, the intuitive dimension-based navigation metaphor of OSM can not be easily applied. There are also more general approaches for view-based modeling but they are less specific in terms of consistency rules between views and provide little guidance on how to manage and navigate views, for example the Zachman Framework [14]. Regarding the practical use of OSM environments in the future, the biggest challenge is developing appropriate SUM metamodels which can accommodate all the types of views and services that software engineers are accustomed to to- day. For this first prototypical SUM-based environment sup- porting the OSM approach we had a method at our disposal (KobrA) that already defined a full set of orthogonal UML- based views. This allowed us to model the required SUM and view metamodels by simply adapting the UML meta- models, removing and adding model elements as needed.",
        "type": "NarrativeText"
    },
    {
        "element_id": "9cc16135-fee3-4be5-8745-885c8fe40ceb",
        "metadata": {},
        "text": "In doing so we were able to manually ensure that the meta- models fulfilled the two core requirements of SUM-based en- vironments \u2014 (1) being minimalistic and (2) redundancy free. If SUM-based software engineering environments are to take off, and to be introduced into existing, heteroge- neous environments, more sophisticated ways of integrating existing metamodels into a single unified metamodel will be required.",
        "type": "NarrativeText"
    },
    {
        "element_id": "ab0f4f14-755b-4a60-b84d-4d9732bce4d2",
        "metadata": {},
        "text": "8. REFERENCES",
        "type": "ListItem"
    },
    {
        "element_id": "2b2f18fd-26f8-4007-93df-b3998b8b041a",
        "metadata": {},
        "text": "[1] C. Atkinson, J. Bayer, C. Bunse, E. Kamsties, O. Laitenberger, R. Laqua, D. Muthig, B. Paech, J. Wiist, and J. Zettel. Component-Based Product Line Engineering with UML. Addison Wesley, Reading, Massachusetts, USA, 1st edition, November 2001.",
        "type": "NarrativeText"
    },
    {
        "element_id": "211a4375-c891-4d88-a24b-d623ec708e49",
        "metadata": {},
        "text": "[2] C. Atkinson, D. Stoll, and P. Bostan. Orthographic Software Modeling: A Practical Approach to View-Based Development. In Evaluation of Novel Approaches to Software Engineering, volume 69 of",
        "type": "NarrativeText"
    },
    {
        "element_id": "8f2e5dc7-2c6e-4cc9-bb66-1226ff8ee079",
        "metadata": {},
        "text": "[3]",
        "type": "UncategorizedText"
    },
    {
        "element_id": "81ceabfa-94ae-46f5-bdd6-30f61af4c71e",
        "metadata": {},
        "text": "10",
        "type": "UncategorizedText"
    },
    {
        "element_id": "799302bb-55e3-4094-abe2-05caaa5d2273",
        "metadata": {},
        "text": "11",
        "type": "UncategorizedText"
    },
    {
        "element_id": "5291e5c8-4fbc-478d-acdc-7210ce39f271",
        "metadata": {},
        "text": "12",
        "type": "UncategorizedText"
    },
    {
        "element_id": "2fece39b-02de-4a41-b0de-658d9dac04bb",
        "metadata": {},
        "text": "13",
        "type": "UncategorizedText"
    },
    {
        "element_id": "d8873180-c419-42f1-bcc9-3fea8d6835fd",
        "metadata": {},
        "text": "14",
        "type": "UncategorizedText"
    },
    {
        "element_id": "2cf20585-54eb-498a-82f5-457cc0f432f6",
        "metadata": {},
        "text": "Communications in Computer and Information Science, pages 206-219. Springer Berlin Heidelberg, 2010.",
        "type": "NarrativeText"
    },
    {
        "element_id": "ce1c8c52-0036-4e9e-9e27-078eaba484ff",
        "metadata": {},
        "text": "C. Atkinson, D. Stoll, and C. Tunjic. Orthographic Service Modeling. In Proceedings of 15th IEEE EDOC Conference Workshops (EDOCW), Helsinki, Finland, 2011.",
        "type": "NarrativeText"
    },
    {
        "element_id": "cabb558f-c96f-4cea-8700-5683225008f1",
        "metadata": {},
        "text": "Eclipse Foundation. UML2Tools. http://wiki.eclipse.org/MDT-UML2Tools, 2013. ISO/IEC and ITU-T. The Reference Model of Open Distributed Processing. RM-ODP, ITU-T Rec. X.901-X.904 / ISO/IEC 10746. http://standards.iso.org/ ittf/PubliclyAvailableStandards/index.html, 1998.",
        "type": "NarrativeText"
    },
    {
        "element_id": "0151ce62-76be-4a35-88db-cdcfe575befc",
        "metadata": {},
        "text": "J. I. J. Jose Raul Romero and A. Vallecillo. Realizing Correspondences in MultiViewpoint Specifications. In Proceedings of the Thirteenth IEEE International EDOC Conference, 1 - 4 September 2009, Auckland, New Zealand, September 2009.",
        "type": "NarrativeText"
    },
    {
        "element_id": "c96b5764-0b39-457c-a5e3-1046b86f9840",
        "metadata": {},
        "text": "M. Lankhorst. Enterprise Architecture at Work. Springer Berlin Heidelberg, 2009.",
        "type": "NarrativeText"
    },
    {
        "element_id": "ae42c706-defd-44ed-b9d9-5dcee9e31c76",
        "metadata": {},
        "text": "Object Management Group (OMG). OMG Unified Modeling Language (OMG UML), Superstructure, V2.1.2. http://www.omg.org/cgi-bin/doc?formal/07- 11-02, November 2007.",
        "type": "NarrativeText"
    },
    {
        "element_id": "0786df47-d4ee-44f1-8d7c-27a40876f393",
        "metadata": {},
        "text": "Object Management Group (OMG). Meta Object Facility (MOF) 2.0 Query/View/Transformation, v1.0. http: //www.omg.org/spec/QVT/1.0/PDF/, April 2008. C. Seybold, M. Glinz, S. Meier, and N. Merlo-Schett. An effective layout adaptation technique for a graphical modeling tool. In Proceedings of the 2003 International Conference on Software Engineering, Portland, 2003.",
        "type": "NarrativeText"
    },
    {
        "element_id": "58b640de-f647-4400-b54e-ae3e74bd6643",
        "metadata": {},
        "text": "The Atlas Transformation Language (ATL). Official Website. http: //www.eclipse.org/at1/, 2013.",
        "type": "NarrativeText"
    },
    {
        "element_id": "c33c7b8b-79f6-4dfe-ae91-570a595ea873",
        "metadata": {},
        "text": "The Open Group. TOGAF Version 9 - The Open Group Architecture Framework. http://www.opengroup. org/architecture/ togaf9-doc/arch/index.html, Feb 2009.",
        "type": "NarrativeText"
    },
    {
        "element_id": "54d126ed-3279-452b-bfc8-334e8c988b5e",
        "metadata": {},
        "text": "University of Mannheim - Software Engineering Group. nAOMi - opeN, Adaptable, Orthographic Modeling Envlronment. http://eclipselabs.org/p/naomi.",
        "type": "NarrativeText"
    },
    {
        "element_id": "4f033116-f85b-4021-a37e-39b89ec0a83a",
        "metadata": {},
        "text": "J. A. Zachman. The Zachman Framework: A Primer for Enterprise Engineering and Manufacturing. http://www.zachmaninternational.com, 2009.",
        "type": "UncategorizedText"
    },
    {
        "element_id": "eb939bdb-5493-44e2-bb43-05b50334ad9f",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    }
]