[
    {
        "element_id": "f715517e-3eb8-445e-bf0b-edcc69bb0127",
        "metadata": {},
        "text": "Check for updates.",
        "type": "Title"
    },
    {
        "element_id": "9d55b63a-8c54-4a08-a6bc-94052b2de462",
        "metadata": {},
        "text": "How to Teach Software Modeling",
        "type": "Title"
    },
    {
        "element_id": "46468002-4f63-415e-bb54-ce851ac5808e",
        "metadata": {},
        "text": "Tetsuo Tamai Graduate School of Arts and Sciences The University of Tokyo 3-8-1 Komaba, Meguro-ku Tokyo 153-8902, Japan",
        "type": "UncategorizedText"
    },
    {
        "element_id": "5ba43ae5-93bb-4032-8afc-6226bcd70c0c",
        "metadata": {},
        "text": "tamai@acm.org",
        "type": "EmailAddress"
    },
    {
        "element_id": "6330bf68-eadd-43ba-92a1-8fd51fba0b87",
        "metadata": {},
        "text": "ABSTRACT",
        "type": "Title"
    },
    {
        "element_id": "d28cfa83-6462-4d3c-90d4-b1a862f2bd10",
        "metadata": {},
        "text": "To enhance motivation of students to study software engineering, some way of finding balance between the scientific aspect and the practical aspect of software engineering is required. In this paper, we claim that teaching multiple software modeling techniques from a unified viewpoint is a good way of obtaining the balance and attracting the students\u2019 interest as well.",
        "type": "NarrativeText"
    },
    {
        "element_id": "4cfea270-03f9-4730-9df8-8112bce3312a",
        "metadata": {},
        "text": "Categories and Subject Descriptors",
        "type": "Title"
    },
    {
        "element_id": "a98ce0d0-0597-406e-a35a-8c890cc7080a",
        "metadata": {},
        "text": "K.3.2 [Computers and Education]: Computer and Information Science Education\u2014computer science education; D.2.1 [Software Engineering]: Requirements/Specification\u2014modeling",
        "type": "UncategorizedText"
    },
    {
        "element_id": "066c8f29-9ae7-4ffd-9325-c33d65ba543d",
        "metadata": {},
        "text": "General Terms Design",
        "type": "Title"
    },
    {
        "element_id": "1cda4333-3e6a-4d8e-ad2b-dbf2c0778869",
        "metadata": {},
        "text": "Keywords",
        "type": "Title"
    },
    {
        "element_id": "4b707b15-dc4e-4ce8-a531-0cd006e36a0e",
        "metadata": {},
        "text": "software modeling, software engineering education, UML",
        "type": "Title"
    },
    {
        "element_id": "f990c8b3-4c6b-4048-8389-5b03aa35a93f",
        "metadata": {},
        "text": "1. INTRODUCTION",
        "type": "ListItem"
    },
    {
        "element_id": "8450e85f-04cd-4117-9264-5fadd4df85e8",
        "metadata": {},
        "text": "Software engineering education at universities faces a common problem; that is regular students do not usually have experience of developing software for practical use and thus are not motivated for software engineering aiming at high quality software production by a project team or a persistent organization. Software projects conducted by students simulating real scale software development may help enhance students\u2019 motivation, although it requires a lot of efforts to prepare such projects and manage them.",
        "type": "NarrativeText"
    },
    {
        "element_id": "41eff077-2f23-455d-9457-04a1b8e61fb5",
        "metadata": {},
        "text": "Another way of solving this problem is to teach those who al- ready have real experience in industry. In our case, there are cur- rently five Ph. D. students under the author\u2019s supervision who are working at companies as well as doing research in our lab. As a by-product, interactions between the part-time students and the other regular students stimulate each other, particularly enlighten- ing the regular students to practical software issues. However, too much emphasis on practicality may bring negligence to science and",
        "type": "NarrativeText"
    },
    {
        "element_id": "2e8bcf44-dc74-424f-9474-8cb65febfdff",
        "metadata": {},
        "text": "Copyright is held by the author/owner. ICSE\u201905, May 15-21, 2005, St. Louis, Missouri, USA. ACM 1-58113-963-2/05/0005.",
        "type": "NarrativeText"
    },
    {
        "element_id": "7c9a1455-8f6e-49c1-b50e-880ea96ef458",
        "metadata": {},
        "text": "technology and may generate anti-intellectualism. A good balance between the scientific aspect and the practical aspect of software engineering should always be pursued.",
        "type": "NarrativeText"
    },
    {
        "element_id": "48471fd4-ad38-49f0-be53-219e1fb7eda0",
        "metadata": {},
        "text": "In our view, teaching various software modeling techniques is a good way to achieve balanced software engineering education. It is needless to say that model is a key concept and modeling is an essential skill in software engineering. There are a variety of mod- eling techniques; some are intuitive and quite accessible to novices, while some are highly sophisticated and attract theory oriented stu- dents and researchers.",
        "type": "NarrativeText"
    },
    {
        "element_id": "6083708a-b043-402d-b1dd-cf2372401c9b",
        "metadata": {},
        "text": "In this paper, we would like to show that it is effective to teach multiple modeling techniques from a unified viewpoint. It is based on our experience of teaching software engineering courses at sev- eral universities in Japan. Recently, the author published a textbook on software engineering, specifically focused on software model- ing (unfortunately, it is written in Japanese)[1]. The book covers the whole area of software engineering, including design, testing and evolution but the modeling part has a role of attracting inter- ests of intelligent students, who may not have much experience in developing real scale software systems. It also gives a consistent viewpoint penetrating through various techniques employed in dif- ferent stages of software engineering.",
        "type": "NarrativeText"
    },
    {
        "element_id": "a98dfdd4-3c82-4485-a157-b457402ba237",
        "metadata": {},
        "text": "2. MODELING TECHNIQUES",
        "type": "ListItem"
    },
    {
        "element_id": "96a7f189-433e-46da-a37f-e1126fb36d2c",
        "metadata": {},
        "text": "In software engineering, models are used for various purposes, e.g. life cycle model, process model, project model, product model, quality model, domain model, requirements model, design model, object model, data model, etc. In the following, we basically focus on requirements and design models but most of the discussions will hold for other kinds of models.",
        "type": "NarrativeText"
    },
    {
        "element_id": "946c6e98-3026-4059-a91c-d45701a52a87",
        "metadata": {},
        "text": "Teaching modeling is almost equal to teaching abstraction. Mod- els are constructed through capturing the crucial properties and structure of the target, abstracting away irrelevant details. Thus, learning how to model is a good training for mastering abstraction.",
        "type": "NarrativeText"
    },
    {
        "element_id": "29240fa4-c9fe-4a5c-98f4-5f349f292ad8",
        "metadata": {},
        "text": "2.1 Graph Representation of Models",
        "type": "Title"
    },
    {
        "element_id": "3f952ad8-a788-4d0d-b6cc-9d2a03beac31",
        "metadata": {},
        "text": "Many software models are represented with diagrams. Wide ac- ceptance of UML symbolizes the trend that diagrams are often pre- ferred to textual languages. Among many types of diagrams, graph structured diagrams are by far the most widely used. The reasons may be as follows.",
        "type": "NarrativeText"
    },
    {
        "element_id": "a84c2d2c-741d-4be4-9afa-ef481c0608ab",
        "metadata": {},
        "text": "1. A most fundamental way for human mind to understand the world is by regarding it as consisting of a set of conceptual units and a set of relations between them. Conceptual units can be naturally illustrated with boxes or circles or whatever closed figures and relations can be illustrated with lines or ar- rows connecting such figures, corresponding to vertices and edges of graphs, respectively.",
        "type": "ListItem"
    },
    {
        "element_id": "e5241160-3173-4bf6-9974-af87d8d7ba02",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    },
    {
        "element_id": "de31bec6-d1b2-4d38-97f2-92106f187fb5",
        "metadata": {},
        "text": "2. It is easy to draw graph structured diagrams by hand or with drawing tools.",
        "type": "ListItem"
    },
    {
        "element_id": "9ff6daed-019e-4d48-9033-2047f12f8fa0",
        "metadata": {},
        "text": "3. Concepts and algorithms of the graph theory are available and often useful in analyzing models represented by graphs. A typical example is reasoning on transitive relations by trac- ing along paths of graphs. Also, the concept of subgraph is highly useful in decomposing higher-level models or cluster- ing lower-level models.",
        "type": "ListItem"
    },
    {
        "element_id": "a8d68d86-881e-45a8-acbb-cc1de155abf0",
        "metadata": {},
        "text": "Accordingly, a number of models share the same structure of graphs. Table 1 shows graph structures of some typical models.",
        "type": "NarrativeText"
    },
    {
        "element_id": "0ac69325-a832-4848-acb6-4b02029703bf",
        "metadata": {},
        "text": "Table 1: Graph structures of typical models",
        "type": "Title"
    },
    {
        "element_id": "721e0524-a185-4c82-ba37-39eb69706d74",
        "metadata": {},
        "text": "model vertex edge",
        "type": "Title"
    },
    {
        "element_id": "0a7f888f-3f8e-44aa-b9cc-5c16fb676fbe",
        "metadata": {},
        "text": "Data flow process data flow",
        "type": "Title"
    },
    {
        "element_id": "31509b32-1696-4cea-acac-5f4986e1dd8d",
        "metadata": {},
        "text": "ER entity relationship",
        "type": "Title"
    },
    {
        "element_id": "5a0d5636-b5f8-4f73-9a6c-d3c3ddfefd07",
        "metadata": {},
        "text": "State transition | state transition",
        "type": "Title"
    },
    {
        "element_id": "68d84e64-ef84-4eb6-b5c1-fdc111252e32",
        "metadata": {},
        "text": "JSD process data stream connection state vector connection",
        "type": "Title"
    },
    {
        "element_id": "592a99b5-2a35-402a-b4fe-cc9a9e66d69f",
        "metadata": {},
        "text": "Activity activity control flow",
        "type": "Title"
    },
    {
        "element_id": "aceb6e4b-6151-4eae-b396-a539ac66bfec",
        "metadata": {},
        "text": "Petri net place, transition | fire and token flow",
        "type": "Title"
    },
    {
        "element_id": "22deb04b-d97a-41c4-9379-6dd1f9a473ab",
        "metadata": {},
        "text": "2.2 Commonality and Difference between Models",
        "type": "Title"
    },
    {
        "element_id": "f0be1cec-9c28-4a62-9515-206e5c0ed728",
        "metadata": {},
        "text": "It is pedagogical to let students notice the common structure shared by a number of models. However, the apparent resemblance often causes confusion. Such confusion can be observed not only in software modeling graphs but in many diagrams found in daily newspapers, magazines, reports, proposals and other documents. It is often the case that one vertex denotes a type of things and an- other denotes quite a different type on the same diagram or one type of edges co-exist with edges with different meaning. Thus, it is important to make students consciously aware the differences between different models. We often experience that when we let students draw data flow diagrams who appear to have understood the data flow model perfectly, the diagrams turn out to be some- thing like control flow graphs.",
        "type": "NarrativeText"
    },
    {
        "element_id": "39c99fc2-44b3-4174-a5fc-e8d839667d25",
        "metadata": {},
        "text": "To show the difference, it is instructive to categorize models rep- resented by graphs. Basically, there are two categories.",
        "type": "NarrativeText"
    },
    {
        "element_id": "65cecdc4-83c9-4f47-bec4-56b881d00292",
        "metadata": {},
        "text": "1. Static models:",
        "type": "ListItem"
    },
    {
        "element_id": "78c4f963-bf6e-431a-a279-eec4a485dff2",
        "metadata": {},
        "text": "An edge connecting vertex A and vertex B represents a rela- tion between A and B. When the edge is undirected, it means \u201cA and B are in some relation\u201d and when directed, it means \u201cA has a relation with B\u201d. Typical examples include entity relationship model, class diagram and semantic network.",
        "type": "NarrativeText"
    },
    {
        "element_id": "4eed1db8-8b7d-4071-9cb2-fd0e0c69bcf0",
        "metadata": {},
        "text": "2. Dynamic models:",
        "type": "ListItem"
    },
    {
        "element_id": "ddcc5c13-6b30-449c-85d6-3099e903ff36",
        "metadata": {},
        "text": "An edge from vertex A to B denotes a move from A to B. The edge in this case is always directed. There are two sub- categories:",
        "type": "NarrativeText"
    },
    {
        "element_id": "28da7a34-b3b5-4157-af24-25253d622a2c",
        "metadata": {},
        "text": "(a) The case where a view of control moves from A to B. Examples are control flow model and state transition model.",
        "type": "NarrativeText"
    },
    {
        "element_id": "df554489-bfde-4f4d-b6c7-5269bbc0a77e",
        "metadata": {},
        "text": "(b) The case where data or objects flow from A to B. Exam- ples are data flow model, work flow model, and trans- portation flow model.",
        "type": "NarrativeText"
    },
    {
        "element_id": "406d86ea-75c6-4b29-9761-dd68384062e7",
        "metadata": {},
        "text": "610",
        "type": "UncategorizedText"
    },
    {
        "element_id": "35c04848-78f9-4b97-981a-b227d8b479b8",
        "metadata": {},
        "text": "Static models and dynamic models may not be easily confused but confusion between different dynamic models are often observed, e.g. data flow and control flow or state transition and activity tran- sition. Since graphs are intuitively understandable, their semantics are apt to be understood ambiguously or misunderstood.",
        "type": "NarrativeText"
    },
    {
        "element_id": "46befddf-bb1f-4e9c-ac8f-06e1e81527e0",
        "metadata": {},
        "text": "3. UML UML diagrams can also be viewed in terms of graph structures. Table 2 shows graph structures of five UML diagrams.",
        "type": "ListItem"
    },
    {
        "element_id": "e4867e4d-5811-43a0-8ccd-6cf489594259",
        "metadata": {},
        "text": "Table 2: Graph structures of UML diagrams",
        "type": "Title"
    },
    {
        "element_id": "88fecf08-f509-49fa-9c1f-b2286d6d5b21",
        "metadata": {},
        "text": "diagram vertex edge",
        "type": "Title"
    },
    {
        "element_id": "691235fb-2e8a-46ed-8ba2-7dcc74f6f605",
        "metadata": {},
        "text": "class diagram class generalization, composition,",
        "type": "UncategorizedText"
    },
    {
        "element_id": "7ee674c8-2969-49a0-915c-1c91b3b9d31d",
        "metadata": {},
        "text": "state machine state transition",
        "type": "Title"
    },
    {
        "element_id": "5cf351e8-a2e1-43d6-aef8-dd2200818d80",
        "metadata": {},
        "text": "activity diagram activity control flow",
        "type": "Title"
    },
    {
        "element_id": "3fad26c4-0050-4720-ac7f-044ffd1f4299",
        "metadata": {},
        "text": "collaboration diagram | object message flow",
        "type": "Title"
    },
    {
        "element_id": "ccbbbf11-4424-4069-9ea6-78f9f3e1e5ef",
        "metadata": {},
        "text": "sequence diagram message message flow",
        "type": "Title"
    },
    {
        "element_id": "4b6abf25-33bb-486f-a7da-08e3cf236750",
        "metadata": {},
        "text": "anchor point",
        "type": "Title"
    },
    {
        "element_id": "08d992c9-122b-43e8-94c6-34a78549a7f1",
        "metadata": {},
        "text": "It is usually not desirable to teach UML per se. UML is a col- lection of miscellaneous diagrams and its specification is continu- sly changing. For the pedagogical purpose, UML had better be regarded catalogue of analysis and design know-how collected around diagrammatic representations. Diagrams should be selected according to the policy of how to teach modeling methods.",
        "type": "NarrativeText"
    },
    {
        "element_id": "7217a02b-258b-415a-94e3-83d496a8b573",
        "metadata": {},
        "text": "Each UML diagram contains overly rich constructs, which some- times blur the essential property of the model. For example, the activity diagram is essentially a control flow diagram but it also in- cludes a notation for data flow description. From the stance of em- phasizing differences between various models, it is not appropriate to include such ad hoc constructs. By the same token, the collab- oration diagram (, renamed to \u201ccommunication diagram\u201d in UML 2) is explained to have the equivalent semantics as the sequence diagram. But if that is the case, significance of the collaboration diagram is considerably limited. The author prefers to regard it as showing collaboration relations between objects, integrating a set of different sequence diagrams.",
        "type": "NarrativeText"
    },
    {
        "element_id": "3759b210-fa80-4c1c-8a7a-161fb92b9bd8",
        "metadata": {},
        "text": "4. CONCLUSION",
        "type": "ListItem"
    },
    {
        "element_id": "52569e48-e0ac-41ce-995f-a4d1d525bc5e",
        "metadata": {},
        "text": "Software modeling is important by itself but teaching modeling in the software engineering course has at least two additional mean- ings. One is to give a bird\u2019s-eye view to the whole software engi- neering through the standpoint of modeling technology. The other is to attract interest of good students who may not have much expe- rience in developing a real-scale software but possess intelligence and will to attack complexity of modern software construction.",
        "type": "NarrativeText"
    },
    {
        "element_id": "9918109a-7240-4de9-83d4-222e085ed201",
        "metadata": {},
        "text": "5. REFERENCES",
        "type": "ListItem"
    },
    {
        "element_id": "aee064d8-6734-4056-a9f1-5be2a17491c5",
        "metadata": {},
        "text": "[1] T. Tamai. Foundations of Software Engineering. wanami Shoten, Tokyo, Japan, 2004. in Japanese.",
        "type": "NarrativeText"
    },
    {
        "element_id": "591ad2bb-ffbd-49b3-8aca-8d4a3a73b5f9",
        "metadata": {},
        "text": "",
        "type": "PageBreak"
    }
]